<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Dew Property Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background: #f5f5f5;
            padding: 20px;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .filters {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .filter-required {
            position: relative;
        }

        .filter-required label {
            font-weight: 700;
            color: #0066cc;
        }

        .filter-required label::after {
            content: ' *';
            color: #dc3545;
            font-weight: 700;
        }

        .filter-required .form-select {
            border: 2px solid #0066cc;
            background-color: #f0f8ff;
        }

        .filter-required .form-select:focus {
            border-color: #0052a3;
            box-shadow: 0 0 0 0.25rem rgba(0, 102, 204, 0.25);
        }

        .btn-primary {
            background: #0066cc;
            border-color: #0066cc;
        }

        .btn-clear-all {
            background: #6c757d;
            border-color: #6c757d;
            color: white;
        }

        .btn-clear-all:hover {
            background: #5a6268;
            border-color: #545b62;
        }

        .btn-primary:hover {
            background: #0052a3;
            border-color: #0052a3;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #fee;
            color: #c00;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .results {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .property-card {
            border: 1px solid #e0e0e0;
            padding: 10px;
            background: #fafafa;
            margin-bottom: 6px;
            border-radius: 4px;
            overflow: hidden;
        }

        .property-card:last-child {
            margin-bottom: 0;
        }

        .property-card.not-visible {
            background: #f5f5f5;
            opacity: 0.6;
            border: 1px solid #d0d0d0;
        }

        .property-card.property-disabled {
            border-left: 5px solid #dc3545 !important;
            background: #fff5f5;
            opacity: 0.7;
        }

        .property-card.property-disabled .property-title-tag {
            background: #ffcdd2 !important;
            color: #b71c1c !important;
            border-color: #ef9a9a !important;
        }

        .property-card.not-visible .property-type {
            background: #999;
        }

        .property-card.not-visible .property-value {
            color: #666;
        }

        .property-sidebar {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: -10px -10px 10px -10px;
            padding: 10px 15px;
            background: #c2e7ff;
            border-bottom: 5px solid #d1d9e6;
        }

        .property-card.not-visible .property-sidebar {
            background: #fa8888;
            border-bottom-color: #cbd5e0;
        }

        .property-card.not-migrated .property-sidebar {
            background: #fff3cd;
            border-bottom-color: #ffeeba;
        }

        .property-card.property-disabled .property-sidebar {
            background: #fee2e2;
            border-bottom-color: #fecaca;
        }

        .property-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .property-type {
            background: #0066cc;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
        }

        .property-position {
            color: #666;
            font-size: 11px;
            text-align: center;
            font-weight: 600;
        }

        .property-title-tag {
            color: #333;
            font-size: 11px;
            font-weight: 600;
            background: #e9ecef;
            border-radius: 3px;
            padding: 3px 6px;
            word-break: break-all;
        }

        .property-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 11px;
            flex: 1;
        }

        .property-info-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .property-label {
            font-weight: 600;
            color: #999;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .property-value {
            color: #333;
            font-size: 10px;
            word-break: break-all;
        }

        .property-main {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .visible-content-section {
            background: #f0f8ff;
            border: 2px solid #0066cc;
            border-radius: 8px;
            padding: 15px;
            position: relative;
        }

        .visible-content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .visible-content-title {
            font-weight: 700;
            color: #0066cc;
            font-size: 14px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .copy-all-btn.copied {
            background: #28a745 !important;
            border-color: #28a745 !important;
        }

        .combined-view {
            display: block;
        }

        .separated-view {
            display: none;
        }

        .combined-content-box {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 600px;
            overflow-y: auto;
        }

        .property-separator {
            margin: 20px 0;
            padding: 10px;
            background: #e9ecef;
            border-left: 4px solid #0066cc;
            font-weight: 600;
            font-size: 11px;
            color: #495057;
        }

        .visible-properties-stack {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .visible-property-item {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .hidden-properties-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hidden-section-title {
            font-weight: 700;
            color: #666;
            font-size: 11px;
            margin-bottom: 3px;
        }

        .slides-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        .slide-item {
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            background: #fff;
            transition: box-shadow 0.2s;
            height: 100%;
        }

        .slide-item.expired {
            opacity: 0.5;
            background: #f5f5f5;
            border-color: #ccc;
        }

        .slide-item.expired .slide-title::before {
            content: 'üïê ';
            color: #999;
        }

        .slide-item:not(.expired):hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .slide-thumbnail {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            background: #f5f5f5;
        }

        .slide-video {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            background: #000;
        }
        /* Compact thumbnail for ministries layout */
        .slide-thumb-small {
            width: 140px;
            height: auto;
            aspect-ratio: 16/9;
            object-fit: cover;
            border-radius: 4px;
            background: #f5f5f5;
        }
        .slide-item.ministries {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: stretch;
        }
        .slide-item.ministries .slide-info {
            flex: 1 1 auto;
        }
        .slide-item.ministries .slide-media {
            width: 100%;
        }
        .btn-link {
            display: inline-block;
            padding: 6px 10px;
            margin-right: 6px;
            background: #007bff;
            color: #fff;
            text-decoration: none;
            border-radius: 4px;
            font-size: 12px;
        }
        .btn-link.secondary {
            background: #6c757d;
        }
        .slides-section.collapsed .slides-gallery,
        .slides-section.collapsed .slides-section-header > .hidden-section-title {
            display: none;
        }
        .slides-section.collapsed .slides-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Collapsed property card (non-visible) - keep header, hide details */
        .property-card.property-collapsed .property-info,
        .property-card.property-collapsed .slides-section,
        .property-card.property-collapsed .hidden-properties-section {
            display: none;
        }

        .property-toggle-btn {
            margin-left: 8px;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
        }

        .slide-info {
            padding: 8px;
            font-size: 11px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        .slide-content {
            flex-grow: 1;
        }

        .slide-buttons-list {
            margin: 6px 0;
            padding: 0;
            list-style: none;
        }

        .slide-buttons-list li {
            font-size: 10px;
            color: #0066cc;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slide-buttons-list li::before {
            content: 'üîò';
            font-size: 8px;
        }

        .slide-buttons-list li.secondary::before {
            content: '‚ö™';
        }

        .slide-mobile-indicator {
            font-size: 9px;
            color: #666;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-top: 4px;
            display: inline-block;
        }

        .slide-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .slide-actions {
            display: flex;
            gap: 5px;
            margin-top: auto;
            padding-top: 8px;
        }

        .download-btn {
            flex: 1;
            padding: 6px 8px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            transition: background 0.2s;
        }

        .download-btn:hover {
            background: #0052a3;
        }

        .download-all-btn {
            padding: 8px 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.2s;
        }

        .download-all-btn:hover {
            background: #218838;
        }

        .slides-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        .slides-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .hidden-properties-flex {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(6, minmax(140px, 1fr));
            align-items: start;
        }

        .property-field {
            background: white;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 6px 8px;
            min-width: 0; /* allow grid to constrain */
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        .field-label {
            font-weight: 600;
            color: #555;
            font-size: 11px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .field-value {
            color: #333;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
            display: block;
            padding: 6px 6px;
            border-radius: 3px;
            background: #fafafa;
        }

        .property-field-full {
            grid-column: 1 / -1; /* span all columns */
            width: 100%;
        }

        .field-value-full {
            color: #333;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
            background: #f9f9f9;
            padding: 6px;
            border-radius: 3px;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow-y: auto;
            position: relative;
            padding-top: 28px;
        }

        .copy-btn-inline {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 4px 10px;
            font-size: 10px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10;
        }

        .copy-btn-inline:hover {
            background: #0052a3;
        }

        .copy-btn-inline.copied {
            background: #28a745;
        }

        /* Consolidated spacing rules applied above; keep this block for legacy overrides removed */

        /* Responsive: on narrow screens use two columns for hidden properties */
        @media (max-width: 900px) {
            .hidden-properties-flex {
                grid-template-columns: repeat(2, 1fr);
            }
            .field-value, .field-value-full {
                max-height: 88px;
            }
            .field-label { font-size: 11px; }
        }

        @media (max-width: 520px) {
            .hidden-properties-flex {
                grid-template-columns: 1fr;
            }
            .field-value, .field-value-full {
                max-height: 120px;
            }
        }

        .field-value.json {
            color: #0066cc;
        }

        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 4px 8px;
            font-size: 11px;
            background: #666;
            z-index: 10;
        }

        .copy-btn:hover {
            background: #444;
        }

        .copy-btn.copied {
            background: #28a745;
        }

        .no-results {
            padding: 40px;
            text-align: center;
            color: #666;
        }

        .stats {
            padding: 15px 20px;
            background: #f9f9f9;
            border-bottom: 2px solid #0066cc;
            font-weight: 600;
            color: #333;
        }

        .metadata-section {
            background: #f8f9fa;
            border: 2px solid #0066cc;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .metadata-section.visible {
            display: block;
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .metadata-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metadata-label {
            font-weight: 700;
            color: #0066cc;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metadata-value {
            color: #333;
            font-size: 13px;
            word-break: break-word;
        }

        .metadata-value.empty {
            color: #999;
            font-style: italic;
        }

        .metadata-value.archived {
            color: #dc3545 !important;
            font-weight: 700;
        }

        /* Slider Overlay Utilities */
        .bg-photo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Use Bootstrap variable if present, default to 0.5 opacity black */
            background-color: rgba(0, 0, 0, var(--bs-bg-opacity, 0.5));
            z-index: 1;
            pointer-events: none;
        }

        /* Opacity Utilities - 5% increments */
        .bg-opacity-0 { --bs-bg-opacity: 0; }
        .bg-opacity-5 { --bs-bg-opacity: 0.05; }
        .bg-opacity-10 { --bs-bg-opacity: 0.10; }
        .bg-opacity-15 { --bs-bg-opacity: 0.15; }
        .bg-opacity-20 { --bs-bg-opacity: 0.20; }
        .bg-opacity-25 { --bs-bg-opacity: 0.25; }
        .bg-opacity-30 { --bs-bg-opacity: 0.30; }
        .bg-opacity-35 { --bs-bg-opacity: 0.35; }
        .bg-opacity-40 { --bs-bg-opacity: 0.40; }
        .bg-opacity-45 { --bs-bg-opacity: 0.45; }
        .bg-opacity-50 { --bs-bg-opacity: 0.50; }
        .bg-opacity-55 { --bs-bg-opacity: 0.55; }
        .bg-opacity-60 { --bs-bg-opacity: 0.60; }
        .bg-opacity-65 { --bs-bg-opacity: 0.65; }
        .bg-opacity-70 { --bs-bg-opacity: 0.70; }
        .bg-opacity-75 { --bs-bg-opacity: 0.75; }
        .bg-opacity-80 { --bs-bg-opacity: 0.80; }
        .bg-opacity-85 { --bs-bg-opacity: 0.85; }
        .bg-opacity-90 { --bs-bg-opacity: 0.90; }
        .bg-opacity-95 { --bs-bg-opacity: 0.95; }
        .bg-opacity-100 { --bs-bg-opacity: 1; }

        /* Ensure z-index layering for caption */
        .carousel-caption {
            z-index: 2;
        }

        .wrapVideo {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 */
            height: 0;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .wrapVideo iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            border: 0;
        }

        /* Salvation Army Background Color Classes */
        .u-sa-whiteBg {
            background-color: #ffffff !important;
        }

        .u-sa-blackBg {
            background-color: #000000 !important;
            color: #ffffff !important;
        }

        .u-sa-greyBg {
            background-color: #5a5a5a !important;
            color: #ffffff !important;
        }

        .u-sa-greyLightBg {
            background-color: #cccccc !important;
        }

        .u-sa-greyVeryLightBg {
            background-color: #f5f5f5 !important;
        }

        .u-sa-redBg {
            background-color: #ed1b2e !important;
            color: #ffffff !important;
        }

        .u-sa-orangeBg {
            background-color: #f89728 !important;
            color: #ffffff !important;
        }

        .u-sa-goldBg {
            background-color: #f8b425 !important;
        }

        .u-sa-creamBg {
            background-color: #f5f1e8 !important;
        }

        .u-sa-greenBg {
            background-color: #00a651 !important;
            color: #ffffff !important;
        }

        .u-sa-tealBg {
            background-color: #00aeef !important;
            color: #ffffff !important;
        }

        .u-sa-blueLightBg {
            background-color: #5eb6e4 !important;
        }

        .u-sa-navyBg {
            background-color: #002d5a !important;
            color: #ffffff !important;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="mb-4">üóÑÔ∏è Mountain Dew Property Viewer</h1>
        
        <div class="filters">
            <div class="row g-3">
                <div class="col-md-6 col-lg-3">
                    <label for="themeFilter" class="form-label">Theme</label>
                    <select id="themeFilter" class="form-select">
                        <option value="">Loading themes...</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-3">
                    <label for="territoryFilter" class="form-label">Territory</label>
                    <select id="territoryFilter" class="form-select">
                        <option value="">All Territories</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-3">
                    <label for="divisionFilter" class="form-label">Division</label>
                    <select id="divisionFilter" class="form-select">
                        <option value="">All Divisions</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-3">
                    <label for="groupFilter" class="form-label">Group</label>
                    <select id="groupFilter" class="form-select">
                        <option value="">All Groups</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-3 filter-required">
                    <label for="siteFilter" class="form-label">Site</label>
                    <select id="siteFilter" class="form-select">
                        <option value="">Select a theme first</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-3">
                    <label for="pageTypeFilter" class="form-label">Page Type</label>
                    <select id="pageTypeFilter" class="form-select">
                        <option value="">All Page Types</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-4 filter-required">
                    <label for="documentFilter" class="form-label">Document</label>
                    <div class="input-group">
                        <button class="btn btn-outline-secondary" type="button" onclick="navigateDocument(-1)" title="Previous Document">¬´</button>
                        <select id="documentFilter" class="form-select">
                            <option value="">Select a site first</option>
                        </select>
                        <button class="btn btn-outline-secondary" type="button" onclick="navigateDocument(1)" title="Next Document">¬ª</button>
                    </div>
                </div>
                <div class="col-md-6 col-lg-2">
                    <label for="publishedFilter" class="form-label">Published Status</label>
                    <select id="publishedFilter" class="form-select">
                        <option value="">All</option>
                        <option value="true">Published</option>
                        <option value="false">Unpublished</option>
                        <option value="archived">Archived</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-2">
                    <label for="propertyTypeFilter" class="form-label">Property Type</label>
                    <select id="propertyTypeFilter" class="form-select">
                        <option value="">All Types</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-2">
                    <label for="visibilityFilter" class="form-label">Property Visibility</label>
                    <select id="visibilityFilter" class="form-select">
                        <option value="">All</option>
                        <option value="true">Visible</option>
                        <option value="false">Hidden</option>
                    </select>
                </div>
                <div class="col-md-6 col-lg-2 d-flex align-items-end">
                    <button id="loadBtn" class="btn btn-primary w-100" onclick="loadProperties()">Load Properties</button>
                </div>
                <div class="col-md-6 col-lg-4 col-xl-4 d-flex align-items-end gap-2">
                    <button class="btn btn-secondary flex-grow-1" onclick="clearAllFilters()">Clear Filters</button>
                    <button class="btn btn-primary text-white flex-grow-1" onclick="openMigrationSite()">View on Migration Site</button>
                    <button class="btn btn-success flex-grow-1" onclick="copyAllVisible(this)">Copy All Properties</button>
                </div>
            </div>
        </div>

        <div id="metadata" class="metadata-section">
            <h3 style="margin-top: 0; color: #0066cc; margin-bottom: 15px;">üìã Site & Document Metadata</h3>
            <div class="row g-3">
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Site Title</span>
                        <span id="meta-site-title" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Site Path Root</span>
                        <span id="meta-site-path" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Document Title</span>
                        <span id="meta-doc-title" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Document URL</span>
                        <span id="meta-doc-url" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Page Type</span>
                        <span id="meta-page-type" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Description</span>
                        <span id="meta-description" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Date Created</span>
                        <span id="meta-date-created" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Date Modified</span>
                        <span id="meta-date-modified" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4" id="meta-deletion-date-container">
                    <div class="metadata-item">
                        <span class="metadata-label">Deletion Date (Archived)</span>
                        <span id="meta-deletion-date" class="metadata-value">-</span>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="metadata-item">
                        <span class="metadata-label">Last Updated by</span>
                        <span id="meta-last-updater" class="metadata-value">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">Loading...</div>
        
        <div id="results" class="results" style="display: none;">
            <div id="manifestInspector"></div>
            <div id="stats" class="stats"></div>
            <div id="propertiesList"></div>
        </div>
    </div>

    <script>
        // Version: 1.1.0 - Session storage support added
        let sites = [];
        let documents = [];
        let properties = [];
        let currentSlides = {}; // Store slides by property ID
        let territories = [];
        let themes = [];
        let divisions = [];
        let groups = [];
        let propertyTypes = new Set();

        // Session storage functions
        function saveFilterState() {
            const filters = {
                theme: document.getElementById('themeFilter').value,
                territory: document.getElementById('territoryFilter').value,
                division: document.getElementById('divisionFilter').value,
                group: document.getElementById('groupFilter').value,
                site: document.getElementById('siteFilter').value,
                pageType: document.getElementById('pageTypeFilter').value,
                document: document.getElementById('documentFilter').value,
                published: document.getElementById('publishedFilter').value,
                propertyType: document.getElementById('propertyTypeFilter').value,
                visibility: document.getElementById('visibilityFilter').value,
                // removed: search input no longer saved
            };
            sessionStorage.setItem('mountaindew_filters', JSON.stringify(filters));
        }

        function loadFilterState() {
            const saved = sessionStorage.getItem('mountaindew_filters');
            if (!saved) return null;
            try {
                return JSON.parse(saved);
            } catch (e) {
                return null;
            }
        }

        function clearFilterState() {
            sessionStorage.removeItem('mountaindew_filters');
        }

        function clearAllFilters() {
            // Clear all dropdowns
            document.getElementById('themeFilter').value = '19'; // Default to Symphony
            document.getElementById('territoryFilter').value = '';
            document.getElementById('divisionFilter').value = '';
            document.getElementById('groupFilter').value = '';
            document.getElementById('siteFilter').value = '';
            document.getElementById('pageTypeFilter').value = '';
            document.getElementById('documentFilter').value = '';
            document.getElementById('publishedFilter').value = '';
            document.getElementById('propertyTypeFilter').value = '';
            document.getElementById('visibilityFilter').value = '';
            // searchFilter removed
            
            // Clear session storage
            clearFilterState();
            
            // Reset dependent dropdowns
            loadTerritories();
            loadSites();
            updateDivisionFilter();
            updateGroupFilter();
            updatePageTypeFilter();
            updateDocumentFilter();
            
            // Hide metadata and clear results
            document.getElementById('metadata').classList.remove('visible');
            document.getElementById('results').innerHTML = '';
        }
        
        // Utility: detect common video file extensions in a URL
        function isVideoUrl(url) {
            if (!url) return false;
            try {
                const lowerUrl = String(url).toLowerCase();
                const videoExt = ['.mp4', '.webm', '.mov', '.ogg'];
                return videoExt.some(ext => lowerUrl.includes(ext));
            } catch (e) {
                return false;
            }
        }

        // Helper: parse custom head content into a properties array
        function getCustomPropertiesArray(doc) {
            if (!doc) return null;
            try {
                // Check all possible locations for the metadata properties array
                let customRaw = doc.custom_head_content || doc.customHeadContent || doc.customHead || doc.custom || doc.properties || doc.details || null;
                if (!customRaw) return null;

                // Parse strings where necessary and prefer the `properties` array
                let custom = customRaw;
                if (typeof custom === 'string') {
                    let parsed = null;
                    try { parsed = JSON.parse(custom); } catch (e) { parsed = null; }
                    
                    // Handle double-encoding or strings that are just "[...]"
                    if (typeof parsed === 'string') {
                        try { parsed = JSON.parse(parsed); } catch (e2) { /* ignore */ }
                    }
                    
                    if (parsed) {
                        custom = parsed;
                    } else {
                        // Regex fallback for non-standard or partial JSON strings
                        const propsMatch = customRaw.match(/"properties"\s*:\s*(\[.*\])/s) || customRaw.match(/properties\s*:\s*(\[.*\])/s);
                        if (propsMatch) {
                            try { custom = { properties: JSON.parse(propsMatch[1]) }; } catch (e3) { /* ignore */ }
                        } else {
                            const arrMatch = customRaw.match(/\[.*\]/s);
                            if (arrMatch) {
                                try { custom = JSON.parse(arrMatch[0]); } catch (e4) { /* ignore */ }
                            }
                        }
                    }
                }

                // Locate the properties array within the resolved object/array
                let propsArr = null;
                if (Array.isArray(custom)) {
                    propsArr = custom;
                } else if (custom && typeof custom === 'object') {
                    let candidate = custom.properties || 
                                    (custom.details && custom.details.properties) || 
                                    custom.items || 
                                    (custom.details && custom.details.items) ||
                                    custom.sections ||
                                    custom.rows;
                    
                    if (Array.isArray(candidate)) {
                        propsArr = candidate;
                    } else if (typeof candidate === 'string') {
                        try { propsArr = JSON.parse(candidate); } catch (e) {
                            const mm = candidate.match(/\[.*\]/s);
                            if (mm) try { propsArr = JSON.parse(mm[0]); } catch (e2) { }
                        }
                    }
                }
                
                return Array.isArray(propsArr) ? propsArr : null;
            } catch (e) {
                console.warn('Error parsing custom properties array', e);
                return null;
            }
        }

        // Helper: get a custom title for a property from the currently-loaded document's
        // custom head content (if available). Returns null if not found.
        function getCustomPropertyTitle(prop) {
            // Priority 1: Server-provided manifest title
            if (prop.manifest_title) return prop.manifest_title;
            
            // Priority 2: Frontend manifest match (fallback)
            const entry = getManifestPropertyEntry(prop);
            if (!entry) return null;
            return (entry.details && entry.details.title) || entry.title || entry.label || null;
        }

        // Helper: directly extract an explicit anchorLink from the document.custom_head_content
        // This bypasses any matching heuristics and looks up manifest entries by id or name.
        function getAnchorFromDocumentManifest(prop) {
            try {
                const doc = window.selectedDocument || null;
                if (!doc) {
                    console.warn('getAnchorFromDocumentManifest: No selectedDocument');
                    return null;
                }
                
                // Debug: Log the document structure
                console.log('Document keys:', Object.keys(doc));
                console.log('custom_head_content exists?', !!doc.custom_head_content);
                console.log('custom_head_content type:', typeof doc.custom_head_content);
                if (doc.custom_head_content) {
                    console.log('custom_head_content sample:', doc.custom_head_content.substring ? doc.custom_head_content.substring(0, 200) : doc.custom_head_content);
                }
                
                const propsArr = getCustomPropertiesArray(doc);
                console.log('getAnchorFromDocumentManifest: propsArr length:', propsArr ? propsArr.length : 'null');
                if (!Array.isArray(propsArr)) {
                    // Fallback: attempt to parse raw custom_head_content directly for stringified properties
                    const raw = doc.custom_head_content || doc.customHeadContent || doc.custom || null;
                    if (raw && typeof raw === 'string') {
                        try {
                            const parsed = JSON.parse(raw);
                            if (parsed) {
                                let candidate = parsed.properties || parsed.details?.properties || parsed.items || parsed.sections || parsed.rows || null;
                                if (typeof candidate === 'string') {
                                    try { propsArr = JSON.parse(candidate); } catch (e) { const mm = candidate.match(/\[.*\]/s); if (mm) try { propsArr = JSON.parse(mm[0]); } catch (e2) { } }
                                } else if (Array.isArray(candidate)) {
                                    propsArr = candidate;
                                }
                            }
                        } catch (e) {
                            // ignore
                        }
                    }
                    if (!Array.isArray(propsArr)) return null;
                }

                const pid = String(prop.id || prop.idProperty || prop.propertyId || prop.key || '').toLowerCase();
                const pname = String(prop.name || prop.manifest_title || prop.property_name || '').toLowerCase();

                for (const raw of propsArr) {
                    if (!raw) continue;
                    let entry = raw;
                    if (typeof raw === 'string') {
                        try { entry = JSON.parse(raw); } catch (e) { entry = { name: raw }; }
                    }

                    const entryId = String(entry.id || entry.details?.id || entry.key || entry.slug || '').toLowerCase();
                    const entryName = String(entry.name || entry.details?.name || entry.title || entry.details?.title || '').toLowerCase();

                    if (pid && entryId && pid === entryId) {
                        const foundAnchor = (entry.details && (entry.details.anchorLink || entry.details.anchor_link || entry.details.anchor)) || entry.anchorLink || entry.anchor_link || entry.anchor || null;
                        console.log(`Found anchor by ID match (${pid}):`, foundAnchor, entry);
                        return foundAnchor;
                    }

                    if (!pid && pname && entryName && pname === entryName) {
                        const foundAnchor = (entry.details && (entry.details.anchorLink || entry.details.anchor_link || entry.details.anchor)) || entry.anchorLink || entry.anchor_link || entry.anchor || null;
                        console.log(`Found anchor by name match (${pname}):`, foundAnchor, entry);
                        return foundAnchor;
                    }
                }

                return null;
            } catch (e) {
                console.warn('Error extracting anchor from manifest', e);
                return null;
            }
        }

        // Helper: get the anchor link (ID) for a property from the custom head content
        function getCustomPropertyAnchor(prop) {
            if (!prop) return null;
            // Priority 0: Manifest explicit anchor stored in document.custom_head_content
            const manifestAnchor = getAnchorFromDocumentManifest(prop);
            if (manifestAnchor) return manifestAnchor;

            // Priority 1: Frontend manifest match (fallback to server-cached manifest entry)
            const entry = getManifestPropertyEntry(prop);
            if (entry) {
                const explicitAnchor = (entry.details && (entry.details.anchorLink || entry.details.anchor_link || entry.details.anchor)) ||
                                       entry.anchorLink || entry.anchor_link || entry.anchor || null;
                if (explicitAnchor) return explicitAnchor;

                const idFallback = (entry.details && (entry.details.idProperty || entry.details.id_property || entry.details.id)) ||
                                   entry.idProperty || entry.id_property || entry.id || entry.slug || entry.key || null;
                if (idFallback) return idFallback;
            }

            // Priority 2: Check if the property object itself has the anchor data (flattened by server)
            const propertyAnchor = prop.anchorLink || prop.anchor_link || prop.anchorId || prop.anchor_id ||
                                  prop.manifest_anchor || prop.manifest_anchor_link || prop.manifest_anchorId || prop.anchor || null;
            if (propertyAnchor) return propertyAnchor;

            return null;
        }

        // Helper: determine if a property is actually visible based on manifest or database
        function isPropertyActuallyVisible(prop) {
            if (!prop) return false;

            // Priority 0: Explicit Force Visible (used for substantial content overrides)
            if (prop.forceVisible) return true;

            // Priority 0.5: DATABASE VISIBILITY (HIGHEST PRIORITY NEGATIVE FILTER)
            // If the property has a 'visible' field in the local DB JSON that is explicitly FALSE,
            // we respect that immediately and treat it as hidden, regardless of content or manifest.
            if (prop.visible !== undefined) {
                const dbVisible = prop.visible === true || prop.visible === 'true' || prop.visible === 1 || prop.visible === '1';
                if (!dbVisible) return false;
            }

            // Priority 1: Manifest status (Server-provided manifest_active)
            // If the manifest says it's ACTIVE, it likely is, regardless of DB settings.
            const isManifestActive = prop.manifest_active === true || prop.manifest_active === 'true' || prop.manifest_active === 1 || prop.manifest_active === '1' || prop.manifest_active === 'yes';

            // CONTENT OVERRIDE: If it has any text or objects, always show it if active
            const content = prop.text_html || '';
            const textOnly = content.replace(/<[^>]*>/g, '').trim();
            const hasObjects = prop.objects_array && prop.objects_array !== 'null' && prop.objects_array !== '[]';
            if ((textOnly.length > 5 || hasObjects) && isManifestActive) return true;

            // Priority 2: DATABASE VISIBILITY (Old location - removed)
            // (Moved to top as Priority 0.5)

            // Priority 3: Final manifest check (Server-provided)
            if (prop.manifest_active === false || prop.manifest_active === 'false' || prop.manifest_active === 0 || prop.manifest_active === '0') {
                // If it has content, we might still want to see it for auditing
                if (textOnly.length > 10 || hasObjects) return true;
                return false;
            }

            return true;
        }

        // Helper: determine if a property should be styled as "disabled" (not active in manifest)
        function isPropertyManifestActive(prop) {
            if (!prop) return false;

            // Priority 1: Server-provided manifest status
            if (prop.manifest_active !== undefined) {
                return prop.manifest_active === true || prop.manifest_active === 'true' || prop.manifest_active === 1 || prop.manifest_active === '1' || prop.manifest_active === 'yes';
            }

            // Priority 2: Frontend manifest match (fallback)
            const manifestEntry = getManifestPropertyEntry(prop);
            if (manifestEntry) {
                const mActive = manifestEntry.active !== undefined ? manifestEntry.active : (manifestEntry.details?.active);
                if (mActive === undefined) return true;
                return mActive === true || mActive === 'true' || mActive === 1 || mActive === '1' || mActive === 'yes';
            }
            return true; // Assume active if not specified in manifest
        }

        // Helper: get the full manifest entry for a property
        function getManifestPropertyEntry(prop) {
            if (!prop) return null;
            if (prop._manifestEntry !== undefined) return prop._manifestEntry;

            try {
                const doc = window.selectedDocument || null;
                if (!doc) return null;

                const propsArr = getCustomPropertiesArray(doc);
                if (!propsArr) {
                    prop._manifestEntry = null;
                    return null;
                }

                // Candidates for the property's ID
                const propIdCandidates = [
                    prop.id,
                    prop.idProperty,
                    prop.fkProperty,
                    prop.property_id,
                    prop.propertyId,
                    prop.key,
                    prop.anchorId,
                    prop.anchor_id,
                    prop.anchorLink
                ].filter(Boolean).map(v => String(v).toLowerCase());

                // Candidates for the property's Name
                const propNameCandidates = [
                    prop.name,
                    prop.property_name,
                    prop.propertyName,
                    prop.property_type,
                    prop.propertyType,
                    prop.manifest_title,
                    prop.db_name
                ].filter(Boolean).map(v => String(v).toLowerCase());

                // Normalize entries and compare against candidates
                for (let entryRaw of propsArr) {
                    if (!entryRaw) continue;
                    let entry = entryRaw;
                    if (typeof entryRaw === 'string') {
                        try { entry = JSON.parse(entryRaw); } catch (e) { entry = { name: entryRaw }; }
                    }

                    const entryIdCandidates = [
                        entry.id,
                        entry.details && entry.details.id,
                        entry.details && (entry.details.idProperty || entry.details.id_property || entry.details.fkProperty || entry.details.fk_property),
                        entry.idProperty,
                        entry.id_property,
                        entry.property_id,
                        entry.propertyId,
                        entry.fkProperty,
                        entry.fk_property,
                        entry.key,
                        entry.slug,
                        entry.details && (entry.details.anchorLink || entry.details.anchor_link || entry.details.anchor),
                        entry.anchorLink,
                        entry.anchor_link,
                        entry.anchor
                    ].filter(Boolean).map(v => String(v).toLowerCase());

                    const entryNameCandidates = [
                        entry.name,
                        entry.details && entry.details.name,
                        entry.property_name,
                        entry.propertyName,
                        entry.title,
                        entry.details && entry.details.title,
                        entry.label,
                        entry.key,
                        entry.slug,
                        entry.property_type,
                        entry.propertyType
                    ].filter(Boolean).map(v => String(v).toLowerCase());

                    // Try to match by any ID candidate
                    if (propIdCandidates.some(id => entryIdCandidates.includes(id))) {
                        prop._manifestEntry = entry;
                        return entry;
                    }

                    // Try to match by name IF the ID match failed and the property name isn't generic
                    if (propNameCandidates.some(name => {
                        if (!name || name.length < 3) return false;
                        return entryNameCandidates.includes(name);
                    })) {
                        prop._manifestEntry = entry;
                        return entry;
                    }
                }

                prop._manifestEntry = null;
                return null;
            } catch (e) {
                console.warn('Error matching manifest entry', e);
                prop._manifestEntry = null;
                return null;
            }
        }

        // Extract division code from group name based on territory
        function extractDivision(groupName, territories) {
            if (!groupName) return null;
            
            // USA Southern Territory (USS) - Check first before Kroc
            // Extract 7 characters: USS_XXX
            if (groupName.startsWith('USS_')) {
                if (groupName.length >= 7) {
                    return groupName.substring(0, 7); // USS_ALM, USS_AOK, USS_ARC, etc.
                } else if (groupName === 'USS_') {
                    return 'USS_'; // Handle USS_ standalone
                }
            }
            
            // USA Central Territory (USC) - first 3 characters
            if (groupName.startsWith('USC_') || groupName.startsWith('USC ')) {
                return groupName.substring(0, 3);
            }
            if (groupName === 'USC') {
                return 'USC';
            }
            
            // USA Eastern Territory (USE) - first 3 characters
            if (groupName.startsWith('USE_') || groupName.startsWith('USE ')) {
                return groupName.substring(0, 3);
            }
            if (groupName === 'USE') {
                return 'USE';
            }
            // Eastern divisions: EPA, MAS, NEO, PRV, SWO
            if (groupName.startsWith('EPA ') || groupName.startsWith('MAS ') || 
                groupName.startsWith('NEO ') || groupName.startsWith('PRV ') || 
                groupName.startsWith('SWO ')) {
                const spaceIndex = groupName.indexOf(' ');
                return groupName.substring(0, spaceIndex);
            }
            if (groupName === 'EPA' || groupName === 'MAS' || groupName === 'NEO' || 
                groupName === 'PRV' || groupName === 'SWO') {
                return groupName;
            }
            
            // USA Western Territory
            // Western divisions: AK, ARC, CAS, CS, DO, GS, HI, IM, NW, SC, SW, THQ
            if (groupName.startsWith('AK ') || groupName.startsWith('ARC ') || 
                groupName.startsWith('CAS ') || groupName.startsWith('CS ') || 
                groupName.startsWith('DO ') || groupName.startsWith('GS ') || 
                groupName.startsWith('HI ') || groupName.startsWith('IM ') || 
                groupName.startsWith('NW ') || groupName.startsWith('SC ') || 
                groupName.startsWith('SW ') || groupName.startsWith('THQ ')) {
                const spaceIndex = groupName.indexOf(' ');
                return groupName.substring(0, spaceIndex);
            }
            if (groupName === 'AK' || groupName === 'ARC' || groupName === 'CAS' || 
                groupName === 'CS' || groupName === 'DO' || groupName === 'GS' || 
                groupName === 'HI' || groupName === 'IM' || groupName === 'NW' || 
                groupName === 'SC' || groupName === 'SW' || groupName === 'THQ') {
                return groupName;
            }
            
            // For other formats, return null (ignored)
            return null;
        }

                        // Initialize global card override state
        if (!window.cardOutlineOverrides) window.cardOutlineOverrides = {};
        
        // Initialize global state for hero overrides
        window.heroOverrides = {};
        window.overlayOverrides = {};

        // Load themes, territories and sites on page load
        window.addEventListener('DOMContentLoaded', async () => {
            await loadThemes();
            await loadTerritories();
            await loadSites();
            
            // Restore saved filter state
            const savedState = loadFilterState();
            if (savedState) {
                // Theme is already restored in loadThemes()
                
                // Restore other filters
                if (savedState.territory) {
                    document.getElementById('territoryFilter').value = savedState.territory;
                }
                if (savedState.division) {
                    document.getElementById('divisionFilter').value = savedState.division;
                }
                if (savedState.group) {
                    document.getElementById('groupFilter').value = savedState.group;
                }
                const savedDocumentId = savedState.document || '';

                if (savedState.site) {
                    document.getElementById('siteFilter').value = savedState.site;
                    // Load documents for the saved site
                    await loadDocuments();
                }
                if (savedState.pageType) {
                    document.getElementById('pageTypeFilter').value = savedState.pageType;
                }
                if (savedState.published) {
                    document.getElementById('publishedFilter').value = savedState.published;
                }
                if (savedState.propertyType) {
                    document.getElementById('propertyTypeFilter').value = savedState.propertyType;
                }
                if (savedState.visibility) {
                    document.getElementById('visibilityFilter').value = savedState.visibility;
                }
                // previously supported searchFilter; removed
                // Ensure document/page-type filters reflect restored selections
                try {
                    // Reload documents so updateDocumentFilter can filter using the restored pageType
                    await loadDocuments();
                    updatePageTypeFilter();
                    updateDocumentFilter();
                    if (savedDocumentId) {
                        const docFilter = document.getElementById('documentFilter');
                        const hasOption = Array.from(docFilter.options || []).some(opt => opt.value === savedDocumentId);
                        if (hasOption) {
                            docFilter.value = savedDocumentId;
                            docFilter.dispatchEvent(new Event('change'));
                        }
                    }
                } catch (e) {
                    console.warn('Refreshing documents/page-type after restore failed:', e);
                }
            }
        });

        function toggleHeroMode(propId) {
            if (!propId) return;
            if (!window.heroOverrides) window.heroOverrides = {};
            
            // Get current state (or derive default)
            // Default logic: true if it's a candidate (pos 1, 1 slide).
            // But if we are clicking this button, it means it was ALREADY a candidate.
            // So we just need to know the *current applied value* to flip it.
            
            const prop = (window.loadedProperties || []).find(p => String(p.id) === String(propId));
            if (!prop) return;
            
            // Determine what the current mode IS
            let currentMode = true; // Default for valid candidates is Hero (true)
            if (window.heroOverrides.hasOwnProperty(propId)) {
                currentMode = window.heroOverrides[propId];
            }
            
            // Flip it
            window.heroOverrides[propId] = !currentMode;
            
            // Re-render
            applyPropertyFilters();
        }

        function toggleCardOutline(propId) {
            if (!propId) return;
            if (!window.cardOutlineOverrides) window.cardOutlineOverrides = {};
            
            // Default state for Bootstrap cards is assumed to be WITH border (true) based on user example
            let currentMode = true;
            if (window.cardOutlineOverrides.hasOwnProperty(propId)) {
                currentMode = window.cardOutlineOverrides[propId];
            }
            
            window.cardOutlineOverrides[propId] = !currentMode;
            applyPropertyFilters();
        }

        function toggleSlideContent(propId) {
            if (!propId) return;
            if (!window.slideContentOverrides) window.slideContentOverrides = {};
            
            // Default: true (show content unless toggled)
            let currentMode = true;
            if (window.slideContentOverrides.hasOwnProperty(propId)) {
                currentMode = window.slideContentOverrides[propId];
            }
            
            window.slideContentOverrides[propId] = !currentMode;
            applyPropertyFilters();
        }

        function toggleOverlayMode(propId) {
            if (!propId) return;
            if (!window.overlayOverrides) window.overlayOverrides = {};
            
            // Default: false (hide overlay unless toggled)
            let currentMode = false;
            if (window.overlayOverrides.hasOwnProperty(propId)) {
                currentMode = window.overlayOverrides[propId];
            }
            
            window.overlayOverrides[propId] = !currentMode;
            applyPropertyFilters();
        }

        async function loadThemes() {
            try {
                const response = await fetch('/api/mountaindew/themes');
                const data = await response.json();
                if (data && data.error) throw new Error(data.error);
                themes = Array.isArray(data) ? data : [];
                
                const themeFilter = document.getElementById('themeFilter');
                themeFilter.innerHTML = '<option value="">All Themes</option>' +
                    themes.map(t => 
                        `<option value="${t.idTheme}">${t.theme_name}</option>`
                    ).join('');
                
                // Restore saved state or default to Symphony Skin (ID 19)
                const savedState = loadFilterState();
                themeFilter.value = savedState?.theme || '19';
            } catch (error) {
                console.error('Failed to load themes:', error);
                // Provide a sensible default so UI remains usable when the API is down
                const themeFilter = document.getElementById('themeFilter');
                if (themeFilter) {
                    themeFilter.innerHTML = '<option value="">All Themes</option><option value="19">Symphony (fallback)</option>';
                    themeFilter.value = '19';
                }
                showError('Failed to load themes: ' + error.message + ' ‚Äî using fallback values.');
            }
        }

        async function loadTerritories() {
            const themeId = document.getElementById('themeFilter').value;
            
            try {
                let url = '/api/mountaindew/territories';
                if (themeId) {
                    url += `?themeId=${themeId}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                if (data && data.error) throw new Error(data.error);
                territories = Array.isArray(data) ? data : [];
                
                const territoryFilter = document.getElementById('territoryFilter');
                territoryFilter.innerHTML = '<option value="">All Territories</option>' +
                    territories.map(t => 
                        `<option value="${t.idTerritory}">${t.territory_name} (${t.territory_code})</option>`
                    ).join('');
            } catch (error) {
                console.error('Failed to load territories:', error);
                const territoryFilter = document.getElementById('territoryFilter');
                if (territoryFilter) {
                    territoryFilter.innerHTML = '<option value="">All Territories</option>';
                }
                showError('Failed to load territories: ' + error.message + ' ‚Äî using fallback values.');
            }
        }

        async function loadSites() {
            const themeId = document.getElementById('themeFilter').value;
            const territoryId = document.getElementById('territoryFilter').value;
            
            try {
                let url = '/api/mountaindew/sites';
                const params = [];
                
                if (themeId) params.push(`themeId=${themeId}`);
                if (territoryId) params.push(`territoryId=${territoryId}`);
                
                if (params.length > 0) {
                    url += '?' + params.join('&');
                }
                
                const response = await fetch(url);
                const data = await response.json();
                if (data && data.error) throw new Error(data.error);
                sites = Array.isArray(data) ? data : [];
                
                const siteFilter = document.getElementById('siteFilter');
                siteFilter.innerHTML = '<option value="">All Sites</option>' +
                    sites.map(site => `<option value="${site.idSite}">${site.title} (${site.site_path_root})</option>`).join('');
                    
                // Extract unique OIDC groups from sites
                // The oidc_group_mapping field contains a single group identifier
                const groupSet = new Set();
                const divisionSet = new Set();
                
                sites.forEach(site => {
                    if (site.oidc_group_mapping) {
                        const groupName = site.oidc_group_mapping.trim();
                        if (groupName) {
                            // Remove INTLAPP_WM_ prefix for display
                            const displayName = groupName.replace(/^INTLAPP_WM_/, '');
                            groupSet.add(displayName);
                            
                            // Extract division based on territory rules
                            const division = extractDivision(displayName, territories);
                            if (division) {
                                divisionSet.add(division);
                            }
                        }
                    }
                });
                
                divisions = Array.from(divisionSet).sort();
                groups = Array.from(groupSet).sort();
                
                // Populate division dropdown
                const divisionFilter = document.getElementById('divisionFilter');
                divisionFilter.innerHTML = '<option value="">All Divisions</option>' +
                    divisions.map(div => `<option value="${div}">${div}</option>`).join('');
                
                const groupFilter = document.getElementById('groupFilter');
                groupFilter.innerHTML = '<option value="">All Groups</option>' +
                    groups.map(group => `<option value="${group}">${group}</option>`).join('');
                    
                // Reset dependent filters
                const docFilter = document.getElementById('documentFilter');
                docFilter.innerHTML = '<option value="">Select a site first</option>';
                documents = [];
                
                // Update page type and document filters
                updatePageTypeFilter();
                updateDocumentFilter();
            } catch (error) {
                console.error('Failed to load sites:', error);
                const siteFilter = document.getElementById('siteFilter');
                if (siteFilter) siteFilter.innerHTML = '<option value="">All Sites</option>';
                // clear dependent filters as well
                const divisionFilter = document.getElementById('divisionFilter');
                if (divisionFilter) divisionFilter.innerHTML = '<option value="">All Divisions</option>';
                const groupFilter = document.getElementById('groupFilter');
                if (groupFilter) groupFilter.innerHTML = '<option value="">All Groups</option>';
                showError('Failed to load sites: ' + error.message + ' ‚Äî using fallback values.');
            }
        }

        async function onSiteChange() {
            await loadDocuments();
            saveFilterState();
        }

        async function loadDocuments() {
            const siteId = document.getElementById('siteFilter').value;
            const docFilter = document.getElementById('documentFilter');
            const pageTypeFilter = document.getElementById('pageTypeFilter');
            try {
                let url = '/api/mountaindew/documents';
                if (siteId) url += `?siteId=${siteId}`;
                const response = await fetch(url);
                const data = await response.json();
                if (data && data.error) throw new Error(data.error);
                documents = Array.isArray(data) ? data : [];

                // Populate page types based on returned documents and current published filter
                const published = document.getElementById('publishedFilter').value;
                let filtered = documents;
                if (published !== '') filtered = filtered.filter(doc => String(doc.published) === published);
                const pageTypes = new Set();
                filtered.forEach(doc => { if (doc.page_type) pageTypes.add(doc.page_type); });
                const currentValue = pageTypeFilter.value;
                pageTypeFilter.innerHTML = '<option value="">All Page Types</option>' +
                    Array.from(pageTypes).sort().map(type => `<option value="${type}">${type}</option>`).join('');
                if (currentValue && pageTypes.has(currentValue)) pageTypeFilter.value = currentValue;

                // Populate document filter using updateDocumentFilter (groups by published)
                updateDocumentFilter();
            } catch (error) {
                console.error('Failed to load documents:', error);
                documents = [];
                if (docFilter) docFilter.innerHTML = '<option value="">All Documents</option>';
                if (pageTypeFilter) pageTypeFilter.innerHTML = '<option value="">All Page Types</option>';
                showError('Failed to load documents: ' + error.message);
            }
        }

        function updateDocumentFilter() {
            const pageType = document.getElementById('pageTypeFilter').value;
            const published = document.getElementById('publishedFilter').value;
            const docFilter = document.getElementById('documentFilter');
            
            let filtered = documents;
            
            if (pageType) {
                filtered = filtered.filter(doc => doc.page_type === pageType);
            }
            
            if (published !== '') {
                if (published === 'archived') {
                    filtered = filtered.filter(doc => !!doc.deletion_date);
                } else {
                    // Filter by published status, but exclude archived unless specifically filtered
                    filtered = filtered.filter(doc => String(doc.published) === published && !doc.deletion_date);
                }
            }
            
            // Sort documents alphabetically by title
            filtered.sort((a, b) => {
                const titleA = (a.title || a.document_url || 'Untitled').toLowerCase();
                const titleB = (b.title || b.document_url || 'Untitled').toLowerCase();
                return titleA.localeCompare(titleB);
            });
            
            // Group by status: Published, Unpublished, or Archived
            const archivedDocs = filtered.filter(doc => doc.deletion_date);
            const nonArchived = filtered.filter(doc => !doc.deletion_date);
            const publishedDocs = nonArchived.filter(doc => doc.published);
            const unpublishedDocs = nonArchived.filter(doc => !doc.published);
            
            let html = '<option value="">All Documents</option>';
            
            if (publishedDocs.length > 0) {
                html += '<optgroup label="Published">';
                html += publishedDocs.map(doc => {
                    const title = doc.title || doc.document_url || 'Untitled';
                    const url = doc.document_url ? ` (${doc.document_url})` : '';
                    return `<option value="${doc.idDocument}">‚úì ${title}${url}</option>`;
                }).join('');
                html += '</optgroup>';
            }
            
            if (unpublishedDocs.length > 0) {
                html += '<optgroup label="Unpublished">';
                html += unpublishedDocs.map(doc => {
                    const title = doc.title || doc.document_url || 'Untitled';
                    const url = doc.document_url ? ` (${doc.document_url})` : '';
                    return `<option value="${doc.idDocument}">‚úó ${title}${url}</option>`;
                }).join('');
                html += '</optgroup>';
            }

            if (archivedDocs.length > 0) {
                html += '<optgroup label="Archived (Deleted)">';
                html += archivedDocs.map(doc => {
                    const title = doc.title || doc.document_url || 'Untitled';
                    const url = doc.document_url ? ` (${doc.document_url})` : '';
                    return `<option value="${doc.idDocument}">üóë ${title}${url}</option>`;
                }).join('');
                html += '</optgroup>';
            }
            
            docFilter.innerHTML = html;

            // If there's exactly one real document, auto-select it
            try {
                const totalDocs = publishedDocs.length + unpublishedDocs.length + archivedDocs.length;
                if (totalDocs === 1) {
                    const onlyDoc = publishedDocs[0] || unpublishedDocs[0] || archivedDocs[0];
                    if (onlyDoc && onlyDoc.idDocument) {
                        docFilter.value = onlyDoc.idDocument;
                        // Trigger change so listeners (saveFilterState) run
                        docFilter.dispatchEvent(new Event('change'));
                    }
                }
            } catch (e) {
                // swallow any unexpected errors to avoid breaking UI
                console.warn('Auto-select single document failed:', e);
            }
        }

        document.getElementById('themeFilter').addEventListener('change', async () => {
            await loadTerritories();
            await loadSites();
            saveFilterState();
        });
        
        document.getElementById('territoryFilter').addEventListener('change', () => {
            loadSites();
            saveFilterState();
        });
        
        document.getElementById('divisionFilter').addEventListener('change', () => {
            const divisionFilterValue = document.getElementById('divisionFilter').value;
            const groupFilter = document.getElementById('groupFilter');
            const siteFilter = document.getElementById('siteFilter');
            
            if (!divisionFilterValue) {
                // Show all groups
                groupFilter.innerHTML = '<option value="">All Groups</option>' +
                    groups.map(group => `<option value="${group}">${group}</option>`).join('');
                // Show all sites
                siteFilter.innerHTML = '<option value="">All Sites</option>' +
                    sites.map(site => `<option value="${site.idSite}">${site.title} (${site.site_path_root})</option>`).join('');
            } else {
                // Filter groups by division
                const filteredGroups = groups.filter(group => {
                    const division = extractDivision(group, territories);
                    return division === divisionFilterValue;
                });
                
                groupFilter.innerHTML = '<option value="">All Groups</option>' +
                    filteredGroups.map(group => `<option value="${group}">${group}</option>`).join('');
                
                // Filter sites by division (via their groups)
                const filteredSites = sites.filter(site => {
                    if (!site.oidc_group_mapping) return false;
                    const siteGroup = site.oidc_group_mapping.trim().replace(/^INTLAPP_WM_/, '');
                    const division = extractDivision(siteGroup, territories);
                    return division === divisionFilterValue;
                });
                
                siteFilter.innerHTML = '<option value="">All Sites</option>' +
                    filteredSites.map(site => `<option value="${site.idSite}">${site.title} (${site.site_path_root})</option>`).join('');
            }
            
            // Reset group and site selections
            groupFilter.value = '';
            siteFilter.value = '';
            saveFilterState();
        });
        
        document.getElementById('groupFilter').addEventListener('change', () => {
            const groupFilter = document.getElementById('groupFilter').value;
            const siteFilter = document.getElementById('siteFilter');
            
            if (!groupFilter) {
                // Show all sites
                siteFilter.innerHTML = '<option value="">All Sites</option>' +
                    sites.map(site => `<option value="${site.idSite}">${site.title} (${site.site_path_root})</option>`).join('');
            } else {
                // Filter sites by selected group
                // Match the entire field value with prefix removed
                const filteredSites = sites.filter(site => {
                    if (!site.oidc_group_mapping) return false;
                    const siteGroup = site.oidc_group_mapping.trim().replace(/^INTLAPP_WM_/, '');
                    return siteGroup === groupFilter;
                });
                
                siteFilter.innerHTML = '<option value="">All Sites</option>' +
                    filteredSites.map(site => `<option value="${site.idSite}">${site.title} (${site.site_path_root})</option>`).join('');
            }
            saveFilterState();
        });
        
        document.getElementById('siteFilter').addEventListener('change', onSiteChange);
        
        document.getElementById('pageTypeFilter').addEventListener('change', () => {
            updateDocumentFilter();
            saveFilterState();
        });
        
        document.getElementById('documentFilter').addEventListener('change', () => {
            saveFilterState();
            loadProperties(); // Automatically load when selection changes
        });

        // Helper: Navigate to previous or next document in the dropdown
        function navigateDocument(direction) {
            const docFilter = document.getElementById('documentFilter');
            const currentIndex = docFilter.selectedIndex;
            
            // Get all valid indices (skip the "All Documents" prompt or "Select a site" prompt)
            const options = Array.from(docFilter.options);
            const validIndices = options
                .map((opt, idx) => opt.value !== "" ? idx : -1)
                .filter(idx => idx !== -1);

            if (validIndices.length === 0) return;

            // Find where we are in the sequence of valid indices
            let sequenceIndex = validIndices.indexOf(currentIndex);
            
            if (sequenceIndex === -1) {
                // If not currently on a valid document, start at first or last
                sequenceIndex = direction > 0 ? 0 : validIndices.length - 1;
            } else {
                // Move in direction
                sequenceIndex += direction;
            }

            // Loop around if needed
            if (sequenceIndex >= validIndices.length) sequenceIndex = 0;
            if (sequenceIndex < 0) sequenceIndex = validIndices.length - 1;

            const targetIndex = validIndices[sequenceIndex];
            docFilter.selectedIndex = targetIndex;
            
            // Trigger change event to load properties
            docFilter.dispatchEvent(new Event('change'));
        }
        
        document.getElementById('publishedFilter').addEventListener('change', () => {
            updatePageTypeFilter();
            updateDocumentFilter();
            saveFilterState();
        });

        // Update the page type dropdown based on currently loaded documents and published filter
        function updatePageTypeFilter() {
            const pageTypeFilter = document.getElementById('pageTypeFilter');
            if (!pageTypeFilter) return;
            const published = document.getElementById('publishedFilter').value;
            let filtered = documents || [];
            if (published !== '') {
                if (published === 'archived') {
                    filtered = filtered.filter(doc => !!doc.deletion_date);
                } else {
                    filtered = filtered.filter(doc => String(doc.published) === published && !doc.deletion_date);
                }
            }
            const pageTypes = new Set();
            filtered.forEach(doc => { if (doc.page_type) pageTypes.add(doc.page_type); });
            const currentValue = pageTypeFilter.value;
            pageTypeFilter.innerHTML = '<option value="">All Page Types</option>' +
                Array.from(pageTypes).sort().map(type => `<option value="${type}">${type}</option>`).join('');
            if (currentValue && pageTypes.has(currentValue)) {
                pageTypeFilter.value = currentValue;
            }
        }

        // Helper: Format ISO date string to local locale
        function formatDate(dateStr) {
            if (!dateStr) return '-';
            try {
                return new Date(dateStr).toLocaleString();
            } catch (e) {
                return dateStr;
            }
        }

        function updateMetadata(site, doc) {
            const metadataSection = document.getElementById('metadata');
            
            if (!site && !doc) {
                metadataSection.classList.remove('visible');
                return;
            }
            
            metadataSection.classList.add('visible');
            
            // Site metadata
            document.getElementById('meta-site-title').textContent = site?.title || '-';
            document.getElementById('meta-site-path').textContent = site?.site_path_root || '-';
            
            // Document metadata
            document.getElementById('meta-doc-title').textContent = doc?.title || '-';
            document.getElementById('meta-doc-url').textContent = doc?.document_url || '-';
            document.getElementById('meta-page-type').textContent = doc?.page_type || '-';
            document.getElementById('meta-description').textContent = doc?.description || '-';
            
            document.getElementById('meta-date-created').textContent = formatDate(doc?.date_created);
            document.getElementById('meta-date-modified').textContent = formatDate(doc?.date_modified);
            
            const deletionDateEl = document.getElementById('meta-deletion-date');
            const deletionDateContainer = document.getElementById('meta-deletion-date-container');
            if (doc?.deletion_date) {
                deletionDateEl.textContent = formatDate(doc.deletion_date);
                deletionDateEl.classList.add('archived');
                deletionDateContainer.querySelector('.metadata-label').style.color = '#dc3545';
                deletionDateContainer.style.display = 'block';
            } else {
                deletionDateContainer.style.display = 'none';
            }

            document.getElementById('meta-last-updater').textContent = doc?.last_updater || '-';
        }

        async function loadProperties() {
            const siteId = document.getElementById('siteFilter').value;
            let documentId = document.getElementById('documentFilter').value;

            if (!documentId) {
                showError('Please select a document');
                // Hide metadata and results sections on error
                document.getElementById('metadata').classList.remove('visible');
                document.getElementById('results').style.display = 'none';
                return;
            }

            // Hide previous results and metadata while loading
            const resultsDiv = document.getElementById('results');
            const metadataSection = document.getElementById('metadata');
            resultsDiv.style.display = 'none';
            metadataSection.classList.remove('visible');

            // CLEAR GLOBAL CACHES/VARIABLES to prevent stale data
            window.currentSlides = {};
            window.loadedProperties = [];
            window.allVisibleText = '';
            // Note: We deliberately do NOT clear user overrides (heroOverrides, etc) so they persist if the user just refreshed the same doc.
            // But if switching documents, we might want to?
            // User requested: "variables or content is not getting stuck or meshed" when NEW document is loaded.
            // So we should probably clear overrides too, or at least be careful.
            // Let's clear them to be safe and ensure a fresh state.
            window.heroOverrides = {};
            window.cardOutlineOverrides = {};
            window.slideContentOverrides = {};
            window.overlayOverrides = {};
            
            showLoading(true);
            hideError();

            try {
                let apiUrl = `/api/mountaindew/properties?documentId=${encodeURIComponent(documentId)}`;
                if (siteId) apiUrl += `&siteId=${encodeURIComponent(siteId)}`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (!response.ok) {
                    console.error('Server error response:', data);
                    throw new Error(data.error || `Server returned ${response.status}`);
                }

                if (data && data.error) {
                    throw new Error(data.error);
                }

                // New logic: Use the returned properties and document metadata
                properties = Array.isArray(data.properties) ? data.properties : (Array.isArray(data) ? data : []);
                window.loadedProperties = properties; // Expose for debugging and raw view

                let selectedDocument = data.document || null;
                
                // Fallback for document metadata if server didn't provide it (older API version)
                if (!selectedDocument) {
                    selectedDocument = documents.find(d => d.idDocument === documentId);
                    if (!selectedDocument && properties.length > 0 && properties[0].fkSite) {
                        selectedDocument = {
                            idDocument: documentId,
                            fkSite: properties[0].fkSite,
                            document_url: 'Manually loaded'
                        };
                    }
                }

                // Site info: Prefer info from the document's actual parent site
                let selectedSite = sites.find(s => s.idSite === (selectedDocument?.fkSite || siteId));
                if (!selectedSite && selectedDocument?.site_title) {
                    selectedSite = {
                        title: selectedDocument.site_title,
                        site_path_root: selectedDocument.site_path_root,
                        idSite: selectedDocument.fkSite,
                        deletion_date: selectedDocument.site_deletion_date // Assumed field from server updates
                    };
                }
                
                // Expose selected document globally
                window.selectedSite = selectedSite || null;
                window.selectedDocument = selectedDocument || null;
                
                // Debug: Log what we got
                console.log('=== DOCUMENT LOADED ===');
                console.log('Document has custom_head_content?', !!selectedDocument?.custom_head_content);
                if (selectedDocument?.custom_head_content) {
                    console.log('custom_head_content type:', typeof selectedDocument.custom_head_content);
                    console.log('custom_head_content sample:', selectedDocument.custom_head_content.substring ? selectedDocument.custom_head_content.substring(0, 300) : selectedDocument.custom_head_content);
                }

                // Pre-map manifest entries to properties for faster lookup and consistency
                if (window.selectedDocument && properties.length > 0) {
                    properties.forEach(p => {
                        getManifestPropertyEntry(p); 
                    });
                }
                
                // Update metadata section using the ACTUAL document/site info
                updateMetadata(window.selectedSite, window.selectedDocument);
                
                // Build property type filter
                    propertyTypes.clear();
                    properties.forEach(prop => { 
                        if (prop.property_type) propertyTypes.add(prop.property_type); 
                    });
                
                const typeFilter = document.getElementById('propertyTypeFilter');
                typeFilter.innerHTML = '<option value="">All Types</option>' +
                    Array.from(propertyTypes).sort().map(type => 
                        `<option value="${type}">${type}</option>`
                    ).join('');

                // Apply all filters
                try {
                    applyPropertyFilters();
                } catch (filterError) {
                     console.error("Filter logic failed", filterError);
                     showError('Properties loaded but filters failed to apply: ' + filterError.message);
                }
            } catch (error) {
                console.error("Critical Load Error", error);
                showError('Failed to load properties: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function applyPropertyFilters() {
            const propertyType = document.getElementById('propertyTypeFilter').value;
            const visibility = document.getElementById('visibilityFilter').value;
            // search-in-values removed ‚Äî do not filter by arbitrary JSON content
            displayProperties(properties, propertyType, visibility);
        }

        function displayProperties(props, typeFilter, visibilityFilter) {
            // Show all properties returned by the API (which are filtered by the manifest on server)
            let filtered = props || [];

            if (typeFilter) {
                filtered = filtered.filter(p => p.property_type === typeFilter);
            }

            if (visibilityFilter !== '') {
                filtered = filtered.filter(p => {
                    const isVisible = isPropertyActuallyVisible(p);
                    return visibilityFilter === 'true' ? isVisible : !isVisible;
                });
            }

            const resultsDiv = document.getElementById('results');
            const statsDiv = document.getElementById('stats');
            const listDiv = document.getElementById('propertiesList');
            const manifestInspector = document.getElementById('manifestInspector');

            // Build Property Inventory Section
            if (props && props.length > 0) {
                let inventoryHtml = `
                    <div style="background: #fff; border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 25px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                        <div style="background: #6610f2; color: white; padding: 12px 20px; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
                            <h5 style="margin: 0; font-size: 16px;">üìÇ Document Property Inventory</h5>
                            <div style="font-size: 12px; font-weight: normal;">${props.length} Properties in Document Manifest</div>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0" style="font-size: 11px;">
                                <thead class="table-light">
                                    <tr>
                                        <th style="padding-left: 20px; width: 50px;">Pos</th>
                                        <th>Property Name / Title</th>
                                        <th>ID</th>
                                        <th>Anchor</th>
                                        <th class="text-center">Visible?</th>
                                        <th class="text-center">In Combined HTML?</th>
                                        <th>Database Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${props.map(p => {
                                        const isVisible = isPropertyActuallyVisible(p);
                                        const isManifestActive = isPropertyManifestActive(p);
                                        // Since there is no DB column, p.visible represents the 'visible' state found INSIDE the property JSON
                                        const isJSONVisible = (p.visible !== undefined) ? (p.visible === true || p.visible === 'true' || p.visible === 1 || p.visible === '1') : true;
                                        
                                        const isFormBuilder = String(p.property_type || '').toLowerCase().includes('formbuilder');
                                        const isMinistries = String(p.property_type || '').toLowerCase().includes('ministr');
                                        // Exclude "See What's Happening" sections - comprehensive check
                                        const propDump = JSON.stringify(p).toLowerCase();
                                        const isSeeWhatsHappening = (String(p.property_type || '').toLowerCase().includes('freetextarea') || String(p.property_type || '').toLowerCase().includes('slide') || String(p.property_type || '').toLowerCase().includes('carousel')) &&
                                            (propDump.includes('seewhatshappening') || (propDump.includes("see what's happening") && propDump.includes("action=")) || (propDump.includes('location-search') && propDump.includes('gdos')));
                                        const isGreatestNeed = propDump.includes('greatestneed');
                                        const isExcludedType = ['locationname', 'threeiconlinks', 'ourleader', 'contactinfo', 'mediaboxhalf', 'interactivestatemap', 'stories', 'mapcontrol', 'localsites'].some(t => String(p.property_type || '').toLowerCase().includes(t));
                                        
                                        // Slide/Hero Detection
                                        const isSlideType = String(p.property_type || '').toLowerCase().includes('slide') || String(p.property_type || '').toLowerCase().includes('carousel');
                                        let isHeroMode = false;
                                        if (isSlideType) {
                                            const items = parseObjectsArray(p.objects_array || p.value);
                                            const slides = items ? parseSlides(items, isSlideType) : [];
                                            const activeSlides = slides.filter(s => !s.isExpired);
                                            const isPosOne = parseInt(p.position, 10) === 1;
                                            const isSingleSlide = activeSlides.length === 1;
                                            isHeroMode = (isPosOne && isSingleSlide);
                                            
                                            // Check override
                                            if (window.heroOverrides && window.heroOverrides.hasOwnProperty(p.id)) {
                                                 isHeroMode = window.heroOverrides[p.id];
                                            }
                                        }

                                        const hasContent = !!(p.text_html || p.objects_array || p.value);
                                        const inTotalHtml = isVisible && hasContent && !isFormBuilder && !isMinistries && !isSeeWhatsHappening && !isGreatestNeed && !isExcludedType && !isHeroMode;
                                        const anchorLink = getCustomPropertyAnchor(p);
                                        
                                        let statusColor = '#198754';
                                        let statusText = 'MATCHED';
                                        if (p.is_syndicated) {
                                            statusColor = '#f59e0b';
                                            statusText = 'MISSING (In Registry Only)';
                                        } else if (p.parse_error) {
                                            statusColor = '#dc3545';
                                            statusText = 'JSON ERROR';
                                        }

                                        let rowStyle = '';
                                        let rowTitle = '';
                                        
                                        if (isSeeWhatsHappening || isGreatestNeed || isMinistries || isExcludedType) {
                                            rowStyle = 'background-color: #fff3cd;';
                                            rowTitle = 'Replaced by Site Editor Features (Not Migrated)';
                                        } else if (!isVisible) {
                                            if (!isJSONVisible) {
                                                rowStyle = 'opacity: 0.6; background: #f8f9fa;';
                                                rowTitle = 'Hidden within property data';
                                            } else if (!isManifestActive) {
                                                rowStyle = 'background: #fff5f5; border-left: 3px solid #dc3545;';
                                                rowTitle = 'Deactivated in Manifest';
                                            } else {
                                                rowStyle = 'opacity: 0.6; background: #f8f9fa;';
                                            }
                                        }

                                        return `
                                            <tr style="${rowStyle}" title="${rowTitle}">
                                                <td style="padding-left: 20px;">${p.position}</td>
                                                <td>
                                                    <div style="font-weight: bold; color: #333;">${escapeHtml(p.manifest_title || p.db_name || p.property_type || 'Unknown')}</div>
                                                    <div style="font-size: 9px; color: #666; display: flex; align-items: center; gap: 5px;">
                                                        Type: ${escapeHtml(p.property_type)}
                                                        ${(() => {
                                                            const itms = parseObjectsArray(p.objects_array || p.value);
                                                            const pType = String(p.property_type || '').toLowerCase();
                                                            const isObjProp = ['slide', 'carousel', 'accordiongroup', 'card', 'tile', 'feature', 'formbuilder', 'ministr'].some(t => pType.includes(t));
                                                            let isEmpt = isObjProp && (!itms || (Array.isArray(itms) && itms.length === 0) || (typeof itms === 'object' && Object.keys(itms).length === 0));
                                                            
                                                            // If not literally empty, check if any items are active
                                                            if (!isEmpt && isObjProp && Array.isArray(itms)) {
                                                                const isSlideType = pType.includes('slide') || pType.includes('carousel');
                                                                const hasActive = itms.some(item => {
                                                                    const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                                                                    const isFeatured = item.featured !== false && item.featured !== 'false' && item.featured !== 0;
                                                                    const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                                                                    
                                                                    // For slides/carousels, we respect featured flag. For others (cards, etc), we ignore it.
                                                                    const isBasicallyActive = isActive && !hasEnded;
                                                                    return isBasicallyActive && (isSlideType ? isFeatured : true);
                                                                });
                                                                if (!hasActive) isEmpt = true;
                                                            }
                                                            
                                                            return isEmpt ? '<span class="badge bg-danger" style="font-size: 8px; padding: 2px 4px;">EMPTY</span>' : '';
                                                        })()}
                                                    </div>
                                                </td>
                                                <td class="text-monospace" style="font-size: 10px;">
                                                    <span title="Click to copy ID" style="cursor: pointer; color: #0066cc;" onclick="navigator.clipboard.writeText('${p.id}'); this.style.color='green'; setTimeout(()=>this.style.color='#0066cc',1000)">${p.id}</span>
                                                </td>
                                                        <td class="text-monospace" style="font-size: 10px; font-weight: 500;">
                                                            ${(() => {
                                                                // Get anchor directly from document.custom_head_content
                                                                const anchor = getAnchorFromDocumentManifest(p) || getCustomPropertyAnchor(p);

                                                                if (anchor) {
                                                                    // Scroll directly to the anchor id if present, otherwise fall back to the property card
                                                                    const target = anchor ? `document.getElementById('${escapeHtml(anchor)}')` : `document.getElementById('propertyCard-${p.id}')`;
                                                                    return `<span title="Scroll to Property" style="cursor: pointer; text-decoration: underline; color: #6610f2;" onclick="( ${target} || document.getElementById('propertyCard-${p.id}') ).scrollIntoView({behavior: 'smooth'})">${escapeHtml(anchor)}</span>`;
                                                                }
                                                                return '<span style="color: #ccc;">-</span>';
                                                            })()}
                                                        </td>
                                                <td class="text-center">
                                                    ${isVisible ? '<span style="color: #198754; font-weight: bold;">‚úì Yes</span>' : '<span style="color: #dc3545;">‚úó No</span>'}
                                                </td>
                                                <td class="text-center">
                                                    ${inTotalHtml ? '<span style="color: #6610f2; font-weight: bold;">YES</span>' : (
                                                        isHeroMode ? '<span style="color: #f59e0b; font-weight:bold; font-size: 10px;">Hero Image</span>' : (
                                                            (isSeeWhatsHappening || isGreatestNeed || isMinistries || isExcludedType) ? 
                                                            '<span style="color: #dc3545; font-weight:bold; font-size: 10px;">Not Migrated</span>' : 
                                                            '<span style="color: #adb5bd;">-</span>'
                                                        )
                                                    )}
                                                </td>
                                                <td style="color: ${statusColor}; font-weight: bold; font-size: 10px;">
                                                    ${statusText}
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                manifestInspector.innerHTML = inventoryHtml;
                manifestInspector.style.display = 'block';
            } else {
                manifestInspector.style.display = 'none';
            }

            if (filtered.length === 0) {
                resultsDiv.style.display = 'block';
                const manifestArray = (getCustomPropertiesArray(window.selectedDocument) || []).filter(reg => {
                    const manifestTitle = String(reg.details?.title || reg.title || reg.label || '').toLowerCase();
                    const regName = String(reg.name || reg.details?.name || reg.type || '').toLowerCase();
                    const regId = String(reg.id || reg.details?.id || reg.idSiteProperty || '').toLowerCase();
                    
                    const isSystem = manifestTitle.includes('pagesettings') || manifestTitle.includes('page settings') ||
                                     regName.includes('pagesettings') || regName.includes('page settings') ||
                                     regId.includes('pagesettings') || regId.includes('page settings') ||
                                     regName.includes('page_settings');
                    return !isSystem;
                });
                const manifestCount = manifestArray.length;
                
                statsDiv.innerHTML = `No properties found${manifestCount > 0 ? ` (Document has ${manifestCount} manifest items)` : ''}`;
                
                let debugMsg = '';
                if (manifestCount > 0) {
                    debugMsg = `
                        <div style="margin-top:20px; padding:20px; background:#fff3cd; border:1px solid #ffeeba; border-radius:8px; color:#856404; text-align:left; max-width:600px; margin-left:auto; margin-right:auto;">
                            <h4 style="margin-top:0;">Registry/Database Mismatch</h4>
                            <p>This document claims to have <strong>${manifestCount}</strong> properties in its manifest, but none matched the current site's data.</p>
                            <p style="font-size:13px;">Possible reasons:
                                <ul style="font-size:12px;">
                                    <li>The property IDs in the registry do not exist in the <code>site_property</code> table for this site.</li>
                                    <li>The properties are "Syndicated" (inherited from a parent site) and not stored locally.</li>
                                    <li>Filters are currently hiding all results.</li>
                                </ul>
                            </p>
                            <div style="margin-top:10px;">
                                <button class="download-all-btn" onclick="console.log('Manifest:', ${JSON.stringify(manifestArray).replace(/"/g, '&quot;')})">Log Manifest to Console</button>
                            </div>
                        </div>
                    `;
                }

                const docId = window.selectedDocument?.idDocument || document.getElementById('documentFilter').value || 'Unknown';
                
                let extraMsg = '';
                if (window.selectedDocument && window.selectedDocument.redirect_external_url) {
                    const url = window.selectedDocument.redirect_external_url;
                    extraMsg = `
                        <div style="margin-top: 20px; padding: 20px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px;">
                            <p class="mb-3">This menu item redirects to <strong>${escapeHtml(url)}</strong></p>
                            <div class="d-flex gap-2 justify-content-center">
                                <a href="${url}" target="_blank" class="btn btn-primary btn-sm">
                                    Open URL
                                </a>
                                <button class="btn btn-outline-secondary btn-sm" onclick="navigator.clipboard.writeText('${url.replace(/'/g, "\\'") }'); this.innerText='Copied!'; setTimeout(()=>this.innerText='Copy URL', 2000)">
                                    Copy URL
                                </button>
                            </div>
                        </div>
                    `;
                }

                listDiv.innerHTML = `
                    <div class="no-results" style="padding:40px;">
                        <span>No properties to display for Document ${escapeHtml(String(docId))}.</span>
                        ${extraMsg}
                        ${debugMsg}
                    </div>`;
                return;
            }

            // Collect all visible content across all filtered properties
            const allVisibleContent = [];
            filtered.forEach(prop => {
                const isVisible = isPropertyActuallyVisible(prop);
                // Exclude formbuilder from automated content generation - handled separately
                const isFormBuilder = String(prop.property_type || '').toLowerCase().includes('formbuilder');
                // Exclude ministries from full combined html as requested
                const isMinistries = String(prop.property_type || '').toLowerCase().includes('ministr');
                // Exclude "See What's Happening" sections
                // Case-insensitive check on entire property object
                const propDump = JSON.stringify(prop).toLowerCase();
                const isSeeWhatsHappening = (String(prop.property_type || '').toLowerCase().includes('freetextarea') || String(prop.property_type || '').toLowerCase().includes('slide') || String(prop.property_type || '').toLowerCase().includes('carousel')) &&
                    (propDump.includes('seewhatshappening') || (propDump.includes("see what's happening") && propDump.includes("action=")) || (propDump.includes('location-search') && propDump.includes('gdos')));

                // Slide/Hero Detection for combined HTML
                const isSlideType = String(prop.property_type || '').toLowerCase().includes('slide') || String(prop.property_type || '').toLowerCase().includes('carousel');
                let isHeroMode = false;
                if (isSlideType) {
                    const items = parseObjectsArray(prop.objects_array || prop.value);
                    const slides = items ? parseSlides(items, isSlideType) : [];
                    const activeSlides = slides.filter(s => !s.isExpired);
                    const isPosOne = parseInt(prop.position, 10) === 1;
                    const isSingleSlide = activeSlides.length === 1;
                    isHeroMode = (isPosOne && isSingleSlide);
                    if (window.heroOverrides && window.heroOverrides.hasOwnProperty(prop.id)) {
                         isHeroMode = window.heroOverrides[prop.id];
                    }
                }

                if (isVisible && !isFormBuilder && !isMinistries && !isSeeWhatsHappening && !isHeroMode) {
                    let content = buildPropertySnapshotHtml(prop);
                    
                    if (content) {
                        // Pass the full prop object to access manifest data (like anchors)
                        content = transformFullHtml(content, prop);
                        
                        // Extract metadata title properly and store in a variable
                        const documentMetadataTitle = getCustomPropertyTitle(prop);
                        
                        allVisibleContent.push({
                            content,
                            type: prop.property_type,
                            position: prop.position,
                            customTitle: documentMetadataTitle
                        });
                    }
                }
            });

            const combinedText = allVisibleContent.map(item => {
                const commentTag = item.customTitle 
                    ? `${item.customTitle} - ${item.type}` 
                    : item.type;
                return `<!-- ${commentTag} -->${item.content}`;
            }).join('\n\n');
            window.allVisibleText = combinedText;

            // Build combined view section
            let html = '';
            if (allVisibleContent.length > 0) {
                html += `
                    <div class="visible-content-section" style="margin-bottom: 20px;">
                        <div class="visible-content-header">
                            <span class="visible-content-title">üìù All Visible Content (${allVisibleContent.length} properties)</span>
                            <div class="header-controls">
                                <button class="btn btn-primary btn-sm" onclick="openMigrationSite()">View on Migration Site</button>
                                <button class="btn btn-success btn-sm" onclick="copyAllVisible(this)">Copy All</button>
                            </div>
                        </div>
                        <div class="combined-view" id="combinedView">
                            <div class="combined-content-box" style="background:#f1f3f5; border: 2px solid #ced4da; font-weight:500;">${allVisibleContent.map(item => {
                                const separatorTitle = item.customTitle || item.type;
                                const commentTitle = item.customTitle ? `${item.customTitle} - ${item.type}` : item.type;
                                return `<div class="property-separator" style="background:#dee2e6; color:#495057; border-bottom:1px solid #ced4da;">${escapeHtml(separatorTitle)} (Pos: ${item.position})</div>${escapeHtml('<!-- ' + commentTitle + ' -->')}${escapeHtml(item.content)}`;
                            }).join('\n\n')}</div>
                        </div>
                        <div class="separated-view" id="separatedView">
                            <div class="visible-properties-stack">
                                ${allVisibleContent.map((item, idx) => {
                                    const separatorTitle = item.customTitle || item.type;
                                    const commentTitle = item.customTitle ? `${item.customTitle} - ${item.type}` : item.type;
                                    return `
                                    <div style="margin-bottom: 20px;">
                                        <div class="property-separator">${escapeHtml(separatorTitle)} (Pos: ${item.position})</div>
                                        <div class="visible-property-item" style="background:#fff; border:1px solid #dee2e6; padding:10px; border-radius:4px;">
                                            <pre style="white-space: pre-wrap; margin:0; font-size:12px; font-family:monospace;">${escapeHtml(item.content)}</pre>
                                        </div>
                                    </div>
                                `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Add individual property cards
            html += '<div style="border-top: 3px solid #0066cc; padding-top: 20px; margin-top: 20px;"><h3 style="color: #666; margin-bottom: 15px; margin-left: 7px;">Individual Properties</h3>';
            html += filtered.map(prop => renderProperty(prop)).join('');
            html += '</div>';

            // Stats alignment: only count truly visible active content for the main status
            const visibleCount = allVisibleContent.length;
            const docTitle = window.selectedDocument?.title || 'this document';
            
            // If there are inactive properties, show the count, otherwise keep it quiet
            const inactiveProperties = filtered.filter(p => !isPropertyActuallyVisible(p));
            const inactiveCount = inactiveProperties.length;
            const inactiveText = (inactiveCount > 0) ? `, ${inactiveCount} inactive/missing` : '';
            
            statsDiv.innerHTML = `Found ${filtered.length} properties associated with <strong>${escapeHtml(docTitle)}</strong> (${visibleCount} active/visible${inactiveText})`;
            
            listDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function renderProperty(prop) {
            // Priority: Determine visibility and active status first
            const isActuallyVisible = isPropertyActuallyVisible(prop);
            const isManifestActive = isPropertyManifestActive(prop);
            const isJSONVisible = (prop.visible !== undefined) ? (prop.visible === true || prop.visible === 'true' || prop.visible === 1 || prop.visible === '1') : true;

            // Exclude "See What's Happening" sections
            const propDump = JSON.stringify(prop).toLowerCase();
            const isSeeWhatsHappening = (String(prop.property_type || '').toLowerCase().includes('freetextarea') || String(prop.property_type || '').toLowerCase().includes('slide') || String(prop.property_type || '').toLowerCase().includes('carousel')) &&
                    (propDump.includes('seewhatshappening') || (propDump.includes("see what's happening") && propDump.includes("action=")) || (propDump.includes('location-search') && propDump.includes('gdos')));
            const isGreatestNeed = propDump.includes('greatestneed');
            const isMinistries = String(prop.property_type || '').toLowerCase().includes('ministr');
            const isExcludedType = ['locationname', 'threeiconlinks', 'ourleader', 'contactinfo', 'mediaboxhalf', 'interactivestatemap', 'stories','mapcontrol', 'localsites'].some(t => String(prop.property_type || '').toLowerCase().includes(t));

            // Separate visible text/html content from other properties
            const visibleContent = [];
            const hiddenProperties = [];
            
            // Collect visible text/html content (including complex types like slides/accordions)
            if (isActuallyVisible && !isSeeWhatsHappening && !isGreatestNeed && !isMinistries && !isExcludedType) {
                let snapshot = buildPropertySnapshotHtml(prop);
                if (snapshot) {
                    // Apply common HTML transformations and anchor wrapping
                    snapshot = transformFullHtml(snapshot, prop, false);
                    visibleContent.push(snapshot);
                }
            }
            
            // Collect hidden/non-visible properties for sidebar
            const skipFields = [
                'position', 'property_type', 'id', 'fkSite', 'name', 'db_name', 
                'visible', 'full_json_value', 'manifest_active', 'manifest_title', 'objects', 'objects_array',
                'fullWidth', 'htmlMode', 'backgroundSource', 'backgroundRepeat', 'applyParallax', 'isConductor',
                'customCssClass', 'isFullWidth', 'hideOnMobile', 'hideOnDesktop', 'anchorId', 'animationType', 'animationDelay', 'animationDuration',
                'paddingTop', 'paddingBottom', 'marginTop', 'marginBottom', 'backgroundColor', 'contentAlignment', 'parallaxSpeed', 'parallaxFactor', 'is_syndicated', 'recovered_content'

            ];
            const sidebarFields = ['id', 'fkSite', 'db_name'];
            const handledFields = new Set();
            
            // Always show text_html in hidden if not visible
            if (!isActuallyVisible && prop.text_html) {
                hiddenProperties.push({label: 'Text/HTML (Hidden)', value: prop.text_html, truncate: false, fullWidth: true});
            }

            // For certain property types, if there is an image URL field, expose a thumbnail + copy action
            let freetextBgImage = null;
            try {
                const lowerType = String(prop.property_type || '').toLowerCase();
                if (lowerType.includes('freetextarea') || lowerType.includes('theatreimage') || lowerType.includes('hero')) {
                    const imageKeys = ['background', 'background_image', 'backgroundImage', 'image', 'image_url', 'imageUrl', 'heroImage', 'src'];
                    for (let k of imageKeys) {
                        const v = prop[k] || (prop[k] === 0 ? prop[k] : null);
                        if (v && typeof v === 'string' && v.match(/https?:\/\/.+\.(png|jpe?g|gif|webp|svg)(\?.*)?$/i)) {
                            freetextBgImage = v;
                            // add a full-width thumbnail entry with explicit thumbnail flag
                            hiddenProperties.push({label: 'Background Image', value: v, truncate: false, fullWidth: true, thumbnail: true});
                            handledFields.add(k); // Mark as handled so the regular loop skips it
                            break;
                        }
                    }
                }
            } catch (e) {
                console.warn('freetextarea thumbnail check failed', e);
            }
            
            // Add objects_array to hidden properties and parse slides if applicable
            let slidesData = null;
            if (prop.objects_array || prop.value) {
                const rawVal = prop.objects_array || prop.value;
                const objectsValue = typeof rawVal === 'string' ? rawVal : JSON.stringify(rawVal, null, 2);
                try {
                    const parsed = parseObjectsArray(objectsValue);
                    if (!parsed) throw new Error('parse failed');

                    // For accordiongroup, render HTML next to Objects Array
                    if (prop.property_type && String(prop.property_type).toLowerCase().includes('accordiongroup')) {
                        const accordionHtml = buildAccordionGroupHtml(parsed, `accordion-${prop.id}`, isActuallyVisible);
                        if (accordionHtml) {
                            hiddenProperties.push({label: 'Accordion HTML', value: accordionHtml, truncate: false, fullWidth: true});
                        }
                    }

                    // For FormBuilder, expose the parsed objects array as the configuration
                    if (prop.property_type && String(prop.property_type).toLowerCase().includes('formbuilder')) {
                         const formConfig = JSON.stringify(parsed, null, 2);
                         hiddenProperties.push({label: 'Form Configuration (JSON)', value: formConfig, truncate: false, fullWidth: true});
                    }

                    // For Cards/Tiles, expose the parsed objects array as the configuration
                    if (prop.property_type && (String(prop.property_type).toLowerCase().includes('card') || String(prop.property_type).toLowerCase().includes('tile') || String(prop.property_type).toLowerCase().includes('feature'))) {
                        const cardConfig = JSON.stringify(parsed, null, 2);
                        hiddenProperties.push({label: 'Card Configuration (JSON)', value: cardConfig, truncate: false, fullWidth: true});
                   }

                    // Parse slides if this is a slides property type OR if objects have background/backgroundMobile fields
                    const isSlideType = String(prop.property_type || '').toLowerCase().includes('slide');
                    const hasBackgroundFields = Array.isArray(parsed) && parsed.length > 0 && 
                                               (parsed[0].background || parsed[0].backgroundMobile);

                    console.log('Checking slide data:', {
                        propertyType: prop.property_type,
                        isSlideType,
                        hasBackgroundFields,
                        parsed
                    });

                    if (isSlideType || hasBackgroundFields) {
                        slidesData = parseSlides(parsed, isSlideType);
                        console.log('Parsed slides data:', slidesData);
                    }
                } catch (e) {
                    if (prop.property_type && String(prop.property_type).toLowerCase().includes('accordiongroup')) {
                        const parsedFallback = parseObjectsArray(objectsValue);
                        const accordionHtml = buildAccordionGroupHtml(parsedFallback, `accordion-${prop.id}`, isActuallyVisible);
                        if (accordionHtml) {
                            hiddenProperties.push({label: 'Accordion HTML', value: accordionHtml, truncate: false, fullWidth: true});
                        }
                    }
                }
            }
            
            // Add other non-null fields to hidden properties
            Object.keys(prop).forEach(key => {
                if (!skipFields.includes(key) && !sidebarFields.includes(key) && !handledFields.has(key) && key !== 'text_html' && key !== 'objects_array' && prop[key] !== null && prop[key] !== undefined && prop[key] !== '') {
                    const value = prop[key];
                    
                    // Skip empty arrays and objects
                    if (Array.isArray(value) && value.length === 0) return;
                    if (value && typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length === 0) return;
                    
                    const stringValue = typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value).trim();
                    
                    // Skip actual strings of "null", "undefined", "[]", or "{}"
                    if (!stringValue || stringValue === 'null' || stringValue === 'undefined' || stringValue === '[]' || stringValue === '{}') return;

                    // Determine whether this field should use full-width
                    const isUrlField = key.includes('image') || key.includes('url') || key.includes('link') || key.includes('src');
                    const hasNewlines = stringValue.indexOf('\n') !== -1 || stringValue.indexOf('\r') !== -1;
                    const isLong = stringValue.length > 200;
                    // Full width for Objects Array or long/multiline content, but NOT for simple URLs
                    const fullWidth = (key === 'objects_array') || hasNewlines || isLong || isUrlField;
                    const truncate = !fullWidth;
                    hiddenProperties.push({label: key, value: stringValue, truncate, fullWidth});
                }
            });

            // Build the combined text for copy-all
            const combinedText = visibleContent.join('\n\n---\n\n');

            const manifestEntry = getManifestPropertyEntry(prop);

            let cardClasses = 'property-card';
            // Collapse inactive/hidden properties AND "Not Migrated" properties
            const isNotMigrated = isSeeWhatsHappening || isGreatestNeed || isMinistries || isExcludedType;
            const isCollapsed = !isActuallyVisible || isNotMigrated;
            
            if (isCollapsed) {
                cardClasses += ' property-collapsed';
                if (isNotMigrated) {
                     cardClasses += ' not-migrated'; // Yellow styling for Not Migrated
                } else if (!isJSONVisible) {
                    cardClasses += ' not-visible'; // Grey styling for Hidden data
                } else if (!isManifestActive) {
                    cardClasses += ' property-disabled'; // Red styling for Manifest deactivated
                } else {
                    cardClasses += ' not-visible';
                }
            }
            if (prop.is_syndicated) cardClasses += ' property-syndicated';

            return `
                <div id="propertyCard-${prop.id}" class="${cardClasses}" data-prop-id="${prop.id}">
                    <div class="property-sidebar">
                        <div class="property-header" style="flex-wrap: wrap; gap: 4px;">
                            ${(() => {
                                let title = prop.manifest_title || (manifestEntry ? ((manifestEntry.details && manifestEntry.details.title) || manifestEntry.title || manifestEntry.label) : null);
                                const type = String(prop.property_type || '').trim();
                                
                                if (!title) {
                                    return `<span class="property-type">${escapeHtml(type)}</span>`;
                                }
                                
                                const isSame = title.toLowerCase() === type.toLowerCase();
                                let titleStyles = 'background:#e9ecef; color:#495057; padding:4px 10px; border-radius:4px; font-weight:700; border: 1px solid #dee2e6;';
                                
                                if (prop.is_syndicated) {
                                    titleStyles = 'background:#ffeb3b; color:#856404; padding:4px 10px; border-radius:4px; font-weight:700; border: 1px solid #fbc02d;';
                                } else if (isNotMigrated) {
                                    titleStyles = 'background:#fff3cd; color:#856404; padding:4px 10px; border-radius:4px; font-weight:700; border: 1px solid #ffeeba;';
                                }

                                const itms = parseObjectsArray(prop.objects_array || prop.value);
                                const pType = String(prop.property_type || '').toLowerCase();
                                const isObjProp = ['slide', 'carousel', 'accordiongroup', 'card', 'tile', 'feature', 'formbuilder', 'ministr'].some(t => pType.includes(t));
                                let isEmpt = isObjProp && (!itms || (Array.isArray(itms) && itms.length === 0) || (typeof itms === 'object' && Object.keys(itms).length === 0));

                                // If not literally empty, check if any items are active
                                if (!isEmpt && isObjProp && Array.isArray(itms)) {
                                    const isSlideType = pType.includes('slide') || pType.includes('carousel');
                                    const hasActive = itms.some(item => {
                                        const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                                        const isFeatured = item.featured !== false && item.featured !== 'false' && item.featured !== 0;
                                        const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                                        
                                        // For slides/carousels, we respect featured flag. For others (cards, etc), we ignore it.
                                        const isBasicallyActive = isActive && !hasEnded;
                                        return isBasicallyActive && (isSlideType ? isFeatured : true);
                                    });
                                    if (!hasActive) isEmpt = true;
                                }

                                return `
                                    <span class="property-title-tag" style="${titleStyles}">${escapeHtml(String(title).trim())}</span>
                                    ${!isSame && type !== 'unknown' ? `<span class="property-type" style="background:#f8f9fa; color:#6c757d; border: 1px solid #e9ecef;">${escapeHtml(type)}</span>` : ''}
                                    ${isEmpt ? `<span class="property-type" style="background:#dc3545; color:white; border: 1px solid #b71c1c; margin-left: 5px;">EMPTY / NO ACTIVE ITEMS</span>` : ''}
                                `;
                            })()}
                            <span class="property-position">Pos: ${String(prop.position).trim()}</span>
                            ${prop.is_syndicated ? '<span class="property-type" style="background:#fff3cd; color:#856404; border:1px solid #ffeeba;">Syndicated</span>' : ''}
                            ${isSeeWhatsHappening ? '<span class="property-type" style="background:#fff3cd; color:#856404; border:1px solid #ffeeba;">Replaced by Location Finder</span>' : ''}
                            ${isGreatestNeed ? '<span class="property-type" style="background:#fff3cd; color:#856404; border:1px solid #ffeeba;">Needs List</span>' : ''}
                            ${isMinistries ? '<span class="property-type" style="background:#fff3cd; color:#856404; border:1px solid #ffeeba;">Replaced by Services</span>' : ''}
                            ${isExcludedType ? '<span class="property-type" style="background:#fff3cd; color:#856404; border:1px solid #ffeeba;">Replaced by Site Editor</span>' : ''}
                            ${isCollapsed ? `<button id="propToggleBtn-${prop.id}" class="property-toggle-btn" onclick="toggleProperty('${prop.id}')">Show Property</button>` : ''}
                        </div>
                        <div class="property-info">
                            <div class="property-info-row">
                                <span class="property-label">ID:</span>
                                <span class="property-value" title="${String(prop.id).trim()}">${String(prop.id).trim()}</span>
                            </div>
                            
                            ${prop.parse_error ? `
                                <div style="margin-top: 10px; padding: 10px; background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; border-radius: 4px; font-size: 11px;">
                                    <strong>JSON Parse Failed:</strong><br/>
                                    <code>${escapeHtml(prop.parse_error)}</code>
                                    <div style="margin-top: 5px; font-size: 10px; opacity: 0.8;">
                                        The data for this property is either malformed (e.g. raw XML or HTML) or not in standard JSON format.
                                    </div>
                                    <button class="download-all-btn" style="margin-top:8px; width:100%; border-color:#f5c6cb; color:#721c24;" 
                                            onclick="viewRawData('${prop.id}')">View Raw DB Value</button>
                                </div>
                            ` : ''}

                            ${prop.is_syndicated ? `
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 11px;">
                                    <strong>Property not in local database.</strong><br/>
                                    This property is likely delivered via <strong>syndication</strong> or a global registry.
                                </div>
                            ` : (isSeeWhatsHappening ? `
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 11px;">
                                    <strong>Replaced by Location Finder.</strong><br/>
                                    This section has been identified as a 'See What's Happening' module. It will be excluded from the combined HTML view.
                                </div>
                            ` : (isGreatestNeed ? `
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 11px;">
                                    <strong>Replaced by Site Editor Features.</strong><br/>
                                    This 'Greatest Need' module will be excluded. Site editors have newer ways to share needs and link to help resources.
                                </div>
                            ` : (isMinistries ? `
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 11px;">
                                    <strong>Replaced by Services.</strong><br/>
                                    Ministries are now handled via the Services features in Site Editor, allowing for detailed program schedules.
                                </div>
                            ` : (isExcludedType ? `
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 11px;">
                                    <strong>Replaced by Site Editor Features.</strong><br/>
                                    This component (${escapeHtml(prop.property_type)}) is not migrated directly, as Site Editors have modernized ways to display this information.
                                </div>
                            ` : `
                                <div class="property-info-row">
                                    <span class="property-label">Document:</span>
                                    <span class="property-value" title="${escapeHtml(String((window.selectedDocument && window.selectedDocument.idDocument) || '').trim())}">${escapeHtml(String((window.selectedDocument && window.selectedDocument.idDocument) || '').trim())}</span>
                                </div>
                                <div class="property-info-row">
                                    <span class="property-label">Visible:</span>
                                    <span class="property-value">${isActuallyVisible ? '‚úì Yes' : '‚úó No'}</span>
                                </div>
                                ${(() => {
                                    const anchor = getCustomPropertyAnchor(prop);
                                    if (anchor) {
                                        return `
                                            <div class="property-info-row">
                                                <span class="property-label">Anchor:</span>
                                                <span class="property-value" style="color: #6610f2; font-weight: 600;">#${escapeHtml(anchor)}</span>
                                            </div>
                                        `;
                                    }
                                    return '';
                                })()}
                                ${visibleContent.length > 0 && isManifestActive ? `
                                    <div style="padding: 3px 8px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 3px; color: #2e7d32; font-size: 10px; font-weight: 600; white-space: nowrap;">
                                        ‚úì In combined view
                                    </div>
                                ` : ''}
                            `))))}
                        </div>
                    </div>
                    ${slidesData && slidesData.length > 0 ? (() => {
                        // Honor property visibility primarily: if property is not visible, no slides are active
                        const activeSlides = isActuallyVisible ? slidesData.filter(s => !s.isExpired) : [];
                        const expiredSlides = isActuallyVisible ? slidesData.filter(s => s.isExpired) : slidesData;
                        const isMinistry = prop.property_type && prop.property_type.toLowerCase().includes('ministr');
                        const collapsedClass = activeSlides.length === 0 ? ' collapsed' : '';
                        
                        // Check hero status override (defaults to true if 1 slide at pos 1)
                        const isPosOne = parseInt(prop.position, 10) === 1;
                        const isSingleSlide = activeSlides.length === 1;
                        let isHeroMode = isPosOne && isSingleSlide;
                        if (!window.heroOverrides) window.heroOverrides = {};
                        if (window.heroOverrides.hasOwnProperty(prop.id)) {
                             isHeroMode = window.heroOverrides[prop.id];
                        }
                        
                        // Check slide content override
                        // Default to TRUE
                        let includeContent = true;
                        if (window.slideContentOverrides && window.slideContentOverrides.hasOwnProperty(prop.id)) {
                            includeContent = window.slideContentOverrides[prop.id];
                        }
                        
                        return `
                        <div id="slidesSection-${prop.id}" class="slides-section${collapsedClass}">
                            <div class="slides-section-header">
                                <div class="hidden-section-title">Slides (${activeSlides.length} active${expiredSlides.length > 0 ? `, ${expiredSlides.length} expired` : ''})</div>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                    <button class="download-all-btn" onclick="copyAllSlidesContent('${prop.id}')">Copy All JSON</button>
                                    ${!isHeroMode ? `<button class="download-all-btn" onclick="copyCarouselHtml('${prop.id}')">Copy Carousel HTML</button>` : ''}
                                    ${activeSlides.length > 1 ? `<button class="download-all-btn" onclick="downloadAllSlides('${prop.id}')">Download All Images</button>` : ''}
                                    ${expiredSlides.length > 0 ? `<button id="expiredToggleBtn-${prop.id}" class="download-all-btn" onclick="toggleExpiredSlides('${prop.id}')">Show Expired Slides (${expiredSlides.length})</button>` : ''}
                                    <button id="slidesToggleBtn-${prop.id}" class="download-all-btn" onclick="toggleSlidesSection('${prop.id}')">${activeSlides.length === 0 ? 'Show Slides' : 'Collapse Slides'}</button>
                                </div>
                                ${isPosOne && isSingleSlide ? `
                                    <div style="margin-top: 10px; padding: 10px; background: ${isHeroMode ? '#fff3cd' : '#d4edda'}; border: 1px solid ${isHeroMode ? '#ffeeba' : '#c3e6cb'}; color: ${isHeroMode ? '#856404' : '#155724'}; border-radius: 4px; font-size: 12px; font-weight: 600; display:flex; justify-content:space-between; align-items:center;">
                                        <span>${isHeroMode ? 'üì∏ Treated as Hero Image (Excluded from combined HTML)' : '‚úÖ Treated as Carousel (Included in combined HTML)'}</span>
                                        <button class="download-all-btn" style="margin-left:8px; background:#000;" onclick="toggleHeroMode('${prop.id}')">${isHeroMode ? 'Switch to Carousel' : 'Switch to Hero'}</button>
                                    </div>
                                ` : ''}
                                ${!isHeroMode ? `
                                    <div style="margin-top: 10px; padding: 10px; background: ${includeContent ? '#d4edda' : '#f8f9fa'}; border: 1px solid ${includeContent ? '#c3e6cb' : '#dee2e6'}; color: ${includeContent ? '#155724' : '#6c757d'}; border-radius: 4px; font-size: 12px; font-weight: 600; display:flex; justify-content:space-between; align-items:center;">
                                        <span>${includeContent ? 'üìù Including Content (Title, Subtitle, Buttons)' : 'üñºÔ∏è Rendering Images Only (Content Hidden)'}</span>
                                        <button class="download-all-btn" style="margin-left:8px; background:#000;" onclick="toggleSlideContent('${prop.id}')">${includeContent ? 'Exclude Content' : 'Include Content'}</button>
                                    </div>
                                ` : ''}
                            </div>
                    ${(() => {
                        // Check if this property type is a Card/Tile/Feature
                        const isCardType = prop.property_type && (
                            prop.property_type.toLowerCase().includes('card') || 
                            prop.property_type.toLowerCase().includes('tile') || 
                            prop.property_type.toLowerCase().includes('feature')
                        );
                        
                        if (!isCardType) return '';
                        
                        // Check outline override (default true)
                        let hasOutline = true;
                        if (window.cardOutlineOverrides && window.cardOutlineOverrides.hasOwnProperty(prop.id)) {
                             hasOutline = window.cardOutlineOverrides[prop.id];
                        }
                        
                        return `
                        <div class="slides-section-header" style="margin-top: 15px; border-top: 1px dashed #ddd; padding-top: 15px;">
                            <div style="font-weight: 600; color: #555;">Layout Options</div>
                            <div style="margin-top: 5px; padding: 10px; background: #e8f5e9; border: 1px solid #c3e6cb; color: #155724; border-radius: 4px; font-size: 12px; font-weight: 600; display:flex; justify-content:space-between; align-items:center;">
                                <span>Using Bootstrap Grid Layout. Card Outline: ${hasOutline ? 'ON' : 'OFF'}</span>
                                <button class="download-all-btn" style="margin-left:8px; background:#fff;" onclick="toggleCardOutline('${prop.id}')">${hasOutline ? 'Remove Outline' : 'Add Outline'}</button>
                            </div>
                        </div>
                        `;
                    })()}

                            <div id="activeGallery-${prop.id}" class="slides-gallery">
                                ${(() => {
                                    const isMinistry = prop.property_type && prop.property_type.toLowerCase().includes('ministr');
                                    return activeSlides.map((slide, idx) => {
                                        const globalIdx = slidesData.indexOf(slide);
                                        // Store slide data globally
                                        if (!window.currentSlides) window.currentSlides = {};
                                        if (!window.currentSlides[prop.id]) window.currentSlides[prop.id] = [];
                                        window.currentSlides[prop.id][globalIdx] = slide;

                                        if (isMinistry) {
                                            // Content-first (image above CTAs) layout for ministries: image -> title/subtitle -> URL/CTAs -> actions
                                            return `
                                            <div class="slide-item ministries${slide.isExpired ? ' expired' : ''}">
                                                <div class="slide-media">
                                                    ${renderSlideMedia(slide)}
                                                </div>
                                                <div class="slide-info">
                                                    <div class="slide-content">
                                                        <div class="slide-title" title="${escapeHtml(slide.title)}">${escapeHtml(slide.title)}</div>
                                                        ${(() => {
                                                            const sub = slide.subtitle || '';
                                                            const desc = slide.description || '';
                                                            const parts = [];
                                                            if (sub) {
                                                                const idS = `slideSubtitle-${prop.id}-${globalIdx}`;
                                                                parts.push(`<div style="margin:6px 0;"><div style="font-size:12px; color:#333;">${escapeHtml(sub)}</div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${idS}')">Copy Desc</button><pre id="${idS}" style="display:none;">${escapeHtml(sub)}</pre></div></div>`);
                                                            }
                                                            if (desc && desc.trim() !== (sub || '').trim()) {
                                                                const idD = `slideDesc-${prop.id}-${globalIdx}`;
                                                                parts.push(`<div style="margin:6px 0;"><div style="font-size:12px; color:#333;"><strong>Description:</strong> ${escapeHtml(desc)}</div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${idD}')">Copy Desc</button><pre id="${idD}" style="display:none;">${escapeHtml(desc)}</pre></div></div>`);
                                                            }
                                                            return parts.join('');
                                                        })()}
                                                        ${slide.buttonUrl || slide.url ? (() => { const value = slide.buttonUrl || slide.url; const id = `slideUrl-${prop.id}-${globalIdx}`; return `<div style="font-size:11px; color:#0066cc; margin-bottom:6px;"><div>URL: <span class="slide-url" title="${escapeHtml(value)}">${escapeHtml(value)}</span></div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${id}')">Copy URL</button><pre id="${id}" style="display:none;">${escapeHtml(value)}</pre></div></div>` })() : ''}
                                                        
                                                        <!-- Detailed Content View -->
                                                        <div style="font-size: 10px; color: #555; margin: 4px 0; border-top: 1px dotted #ccc; padding-top: 4px;">
                                                            ${slide.title ? `<div><strong>Title:</strong> ${escapeHtml(slide.title)}</div>` : ''}
                                                            ${slide.subtitle ? `<div><strong>Subtitle:</strong> ${escapeHtml(slide.subtitle)}</div>` : ''}
                                                            ${slide.buttonText ? `<div><strong>Btn 1:</strong> ${escapeHtml(slide.buttonText)} (${escapeHtml(slide.buttonUrl || '')})</div>` : ''}
                                                            ${slide.secondaryButtonText ? `<div><strong>Btn 2:</strong> ${escapeHtml(slide.secondaryButtonText)} (${escapeHtml(slide.secondaryButtonUrl || '')})</div>` : ''}
                                                            ${slide.alignment ? `<div><strong>Align:</strong> ${escapeHtml(slide.alignment)}</div>` : ''}
                                                            ${slide.filter ? `<div><strong>Filter:</strong> ${escapeHtml(slide.filter)}</div>` : ''}
                                                        </div>

                                                        ${slide.buttonText || slide.secondaryButtonText ? `
                                                            <div style="margin:6px 0;">
                                                                ${slide.buttonText ? `<a class="btn-link" href="${slide.buttonUrl || '#'}" target="_blank" ${!slide.buttonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.buttonText)}</a>` : ''}
                                                                ${slide.secondaryButtonText ? ` <a class="btn-link secondary" href="${slide.secondaryButtonUrl || '#'}" target="_blank" ${!slide.secondaryButtonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.secondaryButtonText)}</a>` : ''}
                                                            </div>
                                                        ` : ''}
                                                        ${slide.hasMobileImage ? `<div class="slide-mobile-indicator">üì± Has mobile version${slide.isMobileYoutube ? ' (YT)' : slide.isMobileVideo ? ' (video)' : ''}</div>` : ''}
                                                        ${slide.isExpired ? `<div style="font-size: 11px; color: #999; margin-top: 6px;">Expired: ${new Date(slide.endDate).toLocaleDateString()}</div>` : ''}
                                                    </div>
                                                    <div class="slide-actions">
                                                        <button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'desktop')">‚¨á ${slide.isYoutube ? 'YT' : slide.isVideo ? 'Video' : 'Image'}</button>
                                                        ${slide.hasMobileImage ? `<button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'mobile')">‚¨á Mobile ${slide.isMobileYoutube ? 'YT' : slide.isMobileVideo ? 'Video' : 'Image'}</button>` : ''}
                                                        <button class="download-btn" style="background: #6c757d;" onclick="copySlideJson('${prop.id}', ${globalIdx}); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy JSON', 1500);">Copy JSON</button>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                        }

                                        // Default layout (image first)
                                        return `
                                        <div class="slide-item${slide.isExpired ? ' expired' : ''}">
                                            ${renderSlideMedia(slide)}
                                            <div class="slide-info">
                                                <div class="slide-content">
                                                    <div class="slide-title" title="${escapeHtml(slide.title)}">${escapeHtml(slide.title)}</div>
                                                    ${slide.subtitle ? `<div style="font-size: 10px; color: #666; margin-bottom: 4px;">${escapeHtml(slide.subtitle)}</div>` : ''}
                                                    
                                                    <!-- Detailed Content View -->
                                                    <div style="font-size: 10px; color: #555; margin: 4px 0; border-top: 1px dotted #ccc; padding-top: 4px;">
                                                        ${slide.title ? `<div><strong>Title:</strong> ${escapeHtml(slide.title)}</div>` : ''}
                                                        ${slide.subtitle ? `<div><strong>Subtitle:</strong> ${escapeHtml(slide.subtitle)}</div>` : ''}
                                                        ${slide.buttonText ? `<div><strong>Btn 1:</strong> ${escapeHtml(slide.buttonText)} (${escapeHtml(slide.buttonUrl || '')})</div>` : ''}
                                                        ${slide.secondaryButtonText ? `<div><strong>Btn 2:</strong> ${escapeHtml(slide.secondaryButtonText)} (${escapeHtml(slide.secondaryButtonUrl || '')})</div>` : ''}
                                                        ${slide.alignment ? `<div><strong>Align:</strong> ${escapeHtml(slide.alignment)}</div>` : ''}
                                                    </div>

                                                    ${slide.buttonText || slide.secondaryButtonText ? `
                                                        <ul class="slide-buttons-list">
                                                            ${slide.buttonText ? `<li><a href="${slide.buttonUrl || '#'}" target="_blank" style="color: inherit; text-decoration: none;" ${!slide.buttonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.buttonText)}</a></li>` : ''}
                                                            ${slide.secondaryButtonText ? `<li class="secondary"><a href="${slide.secondaryButtonUrl || '#'}" target="_blank" style="color: inherit; text-decoration: none;" ${!slide.secondaryButtonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.secondaryButtonText)}</a></li>` : ''}
                                                        </ul>
                                                    ` : ''}
                                                    ${slide.hasMobileImage ? `<div class="slide-mobile-indicator">üì± Has mobile version${slide.isMobileYoutube ? ' (YT)' : slide.isMobileVideo ? ' (video)' : ''}</div>` : ''}
                                                    ${slide.isExpired ? `<div style="font-size: 9px; color: #999; margin-top: 4px;">Expired: ${new Date(slide.endDate).toLocaleDateString()}</div>` : ''}
                                                </div>
                                                <div class="slide-actions">
                                                    <button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'desktop')">‚¨á ${slide.isYoutube ? 'YT' : slide.isVideo ? 'Video' : 'Image'}</button>
                                                    ${slide.hasMobileImage ? `<button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'mobile')">‚¨á Mobile ${slide.isMobileYoutube ? 'YT' : slide.isMobileVideo ? 'Video' : 'Image'}</button>` : ''}
                                                    <button class="download-btn" style="background: #6c757d;" onclick="copySlideJson('${prop.id}', ${globalIdx}); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy JSON', 1500);">Copy JSON</button>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                    }).join('');
                                })()}
                            </div>
                            ${expiredSlides.length > 0 ? `
                                <div id="expiredGallery-${prop.id}" class="slides-gallery" style="display: none; margin-top:12px;">
                                    ${expiredSlides.map((slide) => {
                                        const globalIdx = slidesData.indexOf(slide);
                                        // store expired slide in global storage as well
                                        if (!window.currentSlides) window.currentSlides = {};
                                        if (!window.currentSlides[prop.id]) window.currentSlides[prop.id] = [];
                                        window.currentSlides[prop.id][globalIdx] = slide;

                                        if (isMinistry) {
                                            return `
                                            <div class="slide-item ministries expired">
                                                <div class="slide-info">
                                                    <div class="slide-content">
                                                        <div class="slide-title" title="${escapeHtml(slide.title)}">${escapeHtml(slide.title)}</div>
                                                        ${(() => {
                                                            const sub = slide.subtitle || '';
                                                            const desc = slide.description || '';
                                                            const parts = [];
                                                            if (sub) {
                                                                const idS = `slideSubtitle-${prop.id}-${globalIdx}`;
                                                                parts.push(`<div style="margin:6px 0;"><div style="font-size:12px; color:#333;">${escapeHtml(sub)}</div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${idS}')">Copy Desc</button><pre id="${idS}" style="display:none;">${escapeHtml(sub)}</pre></div></div>`);
                                                            }
                                                            if (desc && desc.trim() !== (sub || '').trim()) {
                                                                const idD = `slideDesc-${prop.id}-${globalIdx}`;
                                                                parts.push(`<div style="margin:6px 0;"><div style="font-size:12px; color:#333;"><strong>Description:</strong> ${escapeHtml(desc)}</div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${idD}')">Copy Desc</button><pre id="${idD}" style="display:none;">${escapeHtml(desc)}</pre></div></div>`);
                                                            }
                                                            return parts.join('');
                                                        })()}
                                                        ${slide.buttonUrl || slide.url ? (() => { const value = slide.buttonUrl || slide.url; const id = `slideUrl-${prop.id}-${globalIdx}`; return `<div style="font-size:11px; color:#0066cc; margin-bottom:6px;"><div>URL: <span class="slide-url" title="${escapeHtml(value)}">${escapeHtml(value)}</span></div><div style="text-align:right; margin-top:6px;"><button class="download-btn" onclick="copyToClipboardById('${id}')">Copy URL</button><pre id="${id}" style="display:none;">${escapeHtml(value)}</pre></div></div>` })() : ''}
                                                        ${slide.buttonText || slide.secondaryButtonText ? `
                                                            <div style="margin:6px 0;">
                                                                ${slide.buttonText ? `<a class="btn-link" href="${slide.buttonUrl || '#'}" target="_blank" ${!slide.buttonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.buttonText)}</a>` : ''}
                                                                ${slide.secondaryButtonText ? ` <a class="btn-link secondary" href="${slide.secondaryButtonUrl || '#'}" target="_blank" ${!slide.secondaryButtonUrl ? 'onclick="return false;"' : ''}>${escapeHtml(slide.secondaryButtonText)}</a>` : ''}
                                                            </div>
                                                        ` : ''}
                                                        <div style="font-size: 11px; color: #999; margin-top: 6px;">Expired: ${new Date(slide.endDate).toLocaleDateString()}</div>
                                                    </div>
                                                    <div class="slide-actions">
                                                        <button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'desktop')">‚¨á ${slide.isYoutube ? 'YT' : slide.isVideo ? 'Video' : 'Image'}</button>
                                                        ${slide.hasMobileImage ? `<button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'mobile')">‚¨á Mobile ${slide.isMobileYoutube ? 'YT' : slide.isMobileVideo ? 'Video' : 'Image'}</button>` : ''}
                                                        <button class="download-btn" style="background: #6c757d;" onclick="copySlideJson('${prop.id}', ${globalIdx}); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy JSON', 1500);">Copy JSON</button>
                                                    </div>
                                                </div>
                                                <div class="slide-media">
                                                    ${renderSlideMedia(slide)}
                                                </div>
                                            </div>
                                        `;
                                        }

                                        return `
                                        <div class="slide-item expired">
                                            ${renderSlideMedia(slide)}
                                            <div class="slide-info">
                                                <div class="slide-title">${escapeHtml(slide.title)}</div>
                                                <div class="slide-actions">
                                                    <button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'desktop')">‚¨á ${slide.isYoutube ? 'YT' : slide.isVideo ? 'Video' : 'Image'}</button>
                                                    ${slide.hasMobileImage ? `<button class="download-btn" onclick="downloadSlideImage('${prop.id}', ${globalIdx}, event, 'mobile')">‚¨á Mobile ${slide.isMobileYoutube ? 'YT' : slide.isMobileVideo ? 'Video' : 'Image'}</button>` : ''}
                                                    <button class="download-btn" style="background: #6c757d;" onclick="copySlideJson('${prop.id}', ${globalIdx}); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy JSON', 1500);">Copy JSON</button>
                                                </div>
                                            </div>
                                        </div>
                                    `}).join('')}
                                </div>
                            ` : ''}
                        </div>
                        `;
                    })() : ''}
                    
                    ${/* Card/Tile rendering with toggle */ ''}
                    ${(() => {
                        const isCardLike = prop.property_type && (
                            prop.property_type.toLowerCase().includes('card') || 
                            prop.property_type.toLowerCase().includes('tile') || 
                            prop.property_type.toLowerCase().includes('feature')
                        );
                        if (!isCardLike) return '';
                        
                        // Check outline override (default true)
                        let hasOutline = true;
                        if (window.cardOutlineOverrides && window.cardOutlineOverrides.hasOwnProperty(prop.id)) {
                             hasOutline = window.cardOutlineOverrides[prop.id];
                        }
                        
                        return `
                        <div style="margin: 10px 8px; display:flex; align-items:center; gap:10px;">
                            <span style="font-size: 11px; font-weight: 600; color: #555; text-transform:uppercase;">Bootstrap Cards:</span>
                            <button class="download-all-btn" onclick="toggleCardOutline('${prop.id}')" style="margin:0; padding:4px 10px; font-size:11px; background: ${hasOutline ? '#e8f5e9' : '#000'}; color: ${hasOutline ? '#2e7d32' : '#666'}; border: 1px solid ${hasOutline ? '#a5d6a7' : '#ccc'};">
                               ${hasOutline ? '‚òë Border Included' : '‚òê Border Excluded'}
                            </button>
                        </div>
                        `;
                    })()}

                    ${/* Worship schedule rendering for worship-type properties */ ''}
                    ${(() => {
                        const isWorship = prop.property_type && prop.property_type.toLowerCase().includes('worship');
                        if (!isWorship) return '';
                        let items = [];
                        try {
                            items = typeof prop.objects_array === 'string' ? JSON.parse(prop.objects_array) : (prop.objects_array || []);
                        } catch (e) {
                            return '';
                        }
                        if (!Array.isArray(items) || items.length === 0) return '';

                        return `
                        <div class="worship-schedule" style="margin:12px 8px;">
                            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                              <div style="font-weight:700;">Program Schedule (${items.length})</div>
                              <div><button class="download-all-btn" onclick="copyToClipboardById('worshipAll-${prop.id}')">Copy All</button></div>
                            </div>
                            <pre id="worshipAll-${prop.id}" style="display:none;">${escapeHtml(items.map(function(it){ return 'Day: ' + (it.day||'') + '\nTime: ' + (it.time||'') + '\nDescription: ' + (it.description||''); }).join('\n\n'))}</pre>
                            <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:flex-start;">
                                ${items.map((it, i) => {
                                    const copyId = `worshipItem-${prop.id}-${i}`;
                                    const day = it.day || '';
                                    const time = it.time || '';
                                    const desc = it.description || '';
                                    const formatted = `Day: ${day}\nTime: ${time}\nDescription: ${desc}`;
                                    return `
                                    <div class="worship-card" style="border:1px solid rgba(0,0,0,0.08); border-left:6px solid #0066cc; padding:8px; border-radius:6px; background:#fff; display:flex; justify-content:space-between; align-items:flex-start; gap:12px; flex:1 1 320px; min-width:220px; box-sizing:border-box; box-shadow: 0 1px 3px rgba(0,0,0,0.06);">
                                        <div style="flex:1;">
                                            <div style="font-size:13px; font-weight:600; color:#333;">${escapeHtml(day)} <span style=\"font-weight:400; color:#666; margin-left:8px;\">${escapeHtml(time)}</span></div>
                                            <div style="font-size:12px; color:#444; margin-top:6px;">${escapeHtml(desc)}</div>
                                        </div>
                                        <div style="flex:none; display:flex; flex-direction:column; gap:6px; align-items:flex-end;">
                                            <button class="copy-btn-inline" onclick="copyToClipboardById('${copyId}')">Copy</button>
                                            <pre id="${copyId}" style="display:none;">${escapeHtml(formatted)}</pre>
                                        </div>
                                    </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        `;
                    })()}

                    ${freetextBgImage ? (() => {
                        let hasOverlay = false;
                        if (window.overlayOverrides && window.overlayOverrides.hasOwnProperty(prop.id)) {
                             hasOverlay = window.overlayOverrides[prop.id];
                        }
                        return `
                        <div class="slides-section-header" style="margin-top: 15px; border-top: 1px dashed #ddd; padding-top: 15px;">
                            <div style="font-weight: 600; color: #555;">Background Options</div>
                            <div style="margin-top: 5px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; font-size: 12px; font-weight: 600; display:flex; justify-content:space-between; align-items:center;">
                                <span>Dark Overlay Treatment: ${hasOverlay ? 'ON' : 'OFF'}</span>
                                <button class="download-all-btn" style="margin-left:8px; background:#000;" onclick="toggleOverlayMode('${prop.id}')">${hasOverlay ? 'Remove Overlay' : 'Add Overlay'}</button>
                            </div>
                        </div>
                        `;
                    })() : ''}

                    ${hiddenProperties.length > 0 ? `
                        <div class="hidden-properties-section">
                            <div class="hidden-section-title">Other Properties (${hiddenProperties.length})</div>
                            <div class="row g-2">
                                ${hiddenProperties.map((field, fieldIdx) => {
                                    if (field.fullWidth) {
                                        const fieldId = `fieldValue-${prop.id}-${fieldIdx}`;
                                        // If this entry is a thumbnail-enabled image, render the image + copy control
                                        if (field.thumbnail) {
                                            const thumbId = `thumb-${prop.id}-${fieldIdx}`;
                                            return `
                                            <div class="col-12">
                                                <div class="property-field property-field-full">
                                                    <div class="field-label">${escapeHtml(field.label)}</div>
                                                    <div class="field-value-full" style="display:flex; gap:12px; align-items:center;">
                                                        <div style="flex:none; max-width:160px;"><img id="${thumbId}" src="${escapeHtml(field.value.trim())}" alt="${escapeHtml(field.label)}" style="max-width:160px; max-height:90px; width:100%; height:auto; object-fit:cover; border-radius:4px; border:1px solid rgba(0,0,0,0.06);" onerror="this.style.display='none'"/></div>
                                                        <div style="flex:1;">
                                                            <div style="margin-bottom:8px; word-break:break-all; color:#0066cc; font-size:12px;">${escapeHtml(field.value.trim())}</div>
                                                            <div><button class="copy-btn-inline" onclick="copyToClipboardById('${fieldId}')">Copy URL</button></div>
                                                            <pre id="${fieldId}" style="display:none;">${escapeHtml(field.value.trim())}</pre>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                        }

                                        // If this is hidden text/html, render as a scrollable box like Objects Array
                                        if (field.label === 'Text/HTML (Hidden)') {
                                            return `
                                            <div class="col-12">
                                                <div class="property-field property-field-full">
                                                    <div class="field-label">${escapeHtml(field.label)}</div>
                                                    <div class="field-value-full" style="display:flex; flex-direction:column; gap:8px;">
                                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                                            <div style="font-size:12px; color:#666;">(Hidden document HTML)</div>
                                                            <div><button class="copy-btn-inline" onclick="copyToClipboardById('${fieldId}')">Copy</button></div>
                                                        </div>
                                                        <div style="border:1px solid rgba(0,0,0,0.06); border-radius:4px; padding:8px; background:#fafafa; max-height:600px; overflow:auto;">
                                                            <pre id="${fieldId}" style="white-space: pre-wrap; margin:0; background:transparent; border:none; padding:0;">${escapeHtml(field.value.trim())}</pre>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                        }

                                        return `
                                            <div class="col-12">
                                                <div class="property-field property-field-full">
                                                    <div class="field-label">${escapeHtml(field.label)}</div>
                                                    <div class="field-value-full">
                                                        <button class="copy-btn-inline" onclick="copyToClipboardById('${fieldId}')">Copy</button>
                                                        <pre id="${fieldId}" style="white-space: pre-wrap; margin:0; background:transparent; border:none; padding:0;">${escapeHtml(field.value.trim())}</pre>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    } else {
                                        return `
                                            <div class="col-12 col-sm-6 col-md-4 col-lg-2">
                                                <div class="property-field">
                                                    <div class="field-label">${escapeHtml(field.label)}</div>
                                                    <div class="field-value" title="${escapeHtml(field.value.trim())}">
                                                        ${escapeHtml(field.value.trim())}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function copyAllVisible(btn) {
            const text = window.allVisibleText || '';
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function openMigrationSite() {
            if (!window.selectedSite || !window.selectedDocument) {
                alert('Site or Document not selected');
                return;
            }
            
            const siteRoot = window.selectedSite.site_path_root || '';
            const docUrl = window.selectedDocument.document_url || '';
            
            // Clean up slashes and join parts correctly
            const cleanSiteRoot = siteRoot.replace(/^\/+|\/+$/g, '');
            const cleanDocUrl = docUrl.replace(/^\/+|\/+$/g, '');
            
            const fullUrl = [
                'https://migration.salvationarmy.org',
                cleanSiteRoot,
                cleanDocUrl
            ].filter(Boolean).join('/');

            window.open(fullUrl, '_blank');
        }

        function toggleCombinedView(btn) {
            const combinedView = document.getElementById('combinedView');
            const separatedView = document.getElementById('separatedView');
            
            if (combinedView.style.display === 'none') {
                combinedView.style.display = 'block';
                separatedView.style.display = 'none';
                btn.textContent = 'Show Preview';
            } else {
                combinedView.style.display = 'none';
                separatedView.style.display = 'block';
                btn.textContent = 'Show Escaped';
            }
        }

        function copyToClipboard(btn, text) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        // Copy the text content of an element by id (safe for large JSON blobs)
        function copyToClipboardById(elementId) {
            const el = document.getElementById(elementId);
            if (!el) {
                alert('No content to copy');
                return;
            }
            const text = el.textContent || el.innerText || '';
            navigator.clipboard.writeText(text).then(() => {
                // find the copy button sibling and show feedback
                const container = el.parentElement;
                if (!container) return;
                const btn = container.querySelector('.copy-btn-inline');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = original;
                        btn.classList.remove('copied');
                    }, 2000);
                }
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function applyBtgridResponsiveClasses(html) {
            if (!html || typeof html !== 'string') return html;
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const targets = doc.body.querySelectorAll('.btgrid .row [class]');
                targets.forEach(el => {
                    const classes = Array.from(el.classList || []);
                    const hasColClass = classes.includes('col') || classes.some(c => c.startsWith('col-'));
                    if (hasColClass && !el.classList.contains('col-sm-12')) {
                        el.classList.add('col-sm-12');
                    }
                });
                return doc.body.innerHTML;
            } catch (e) {
                return html;
            }
        }

        function transformFullHtml(content, prop, forCombinedView = true) {
            if (!content) return content;

            const propType = prop ? prop.property_type : null;
            const typeLower = String(propType || '').toLowerCase();
            let updated = applyBtgridResponsiveClasses(content);
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(updated, 'text/html');
                const iframes = Array.from(doc.body.querySelectorAll('iframe'));
                iframes.forEach(iframe => {
                    const src = iframe.getAttribute('src') || '';
                    const isYoutube = src.includes('youtube.com') || src.includes('youtu.be');
                    const isVimeo = src.includes('vimeo.com') || src.includes('player.vimeo.com');
                    // Skip if already wrapped in our specific video container or structure
                    const alreadyWrapped = iframe.closest('.wrapVideo') || iframe.closest('.slide-video-container') || iframe.closest('.video-background');

                    if ((isYoutube || isVimeo) && !alreadyWrapped) {
                        const container = doc.createElement('div');
                        container.className = 'container';
                        const row = doc.createElement('div');
                        row.className = 'row';
                        const col = doc.createElement('div');
                        col.className = 'col-12';
                        const wrap = doc.createElement('div');
                        wrap.className = 'wrapVideo';

                        const clonedIframe = iframe.cloneNode(true);
                        wrap.appendChild(clonedIframe);
                        col.appendChild(wrap);
                        row.appendChild(col);
                        container.appendChild(row);

                        // If it's already wrapped in a ratio container from buildPropertySnapshotHtml, 
                        // replace the ratio container instead of just the iframe to keep clean.
                        const ratioWrapper = iframe.closest('.ratio');
                        if (ratioWrapper) {
                            ratioWrapper.replaceWith(container);
                        } else {
                            iframe.replaceWith(container);
                        }
                    }
                });
                updated = doc.body.innerHTML;
            } catch (e) {
                // keep original content if parsing fails
            }
            // Apply transformations to Rich Text, Cards, Accordions, Tabs, Slides, and HTML blocks
            // Inclusion list expanded for theaterSpace and freeText as requested
            const isTransformable = (
                typeLower.includes('freetext') || 
                typeLower.includes('theaterspace') || 
                typeLower.includes('cards') || 
                typeLower.includes('accordion') || 
                typeLower.includes('tabs') || 
                typeLower.includes('slides') || 
                typeLower.includes('html') ||
                typeLower.includes('rich-text') ||
                typeLower.includes('title') ||
                typeLower.includes('whitetitle')
            );

            if (isTransformable) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(updated, 'text/html');

                    // 0. CONVERT LEGACY BUTTON CLASSES
                    // Convert .btn-red to .btn-primary (per user request for donate buttons and 'give' subdomains)
                    const redBtns = Array.from(doc.body.querySelectorAll('.btn-red'));
                    redBtns.forEach(el => {
                        el.classList.remove('btn-red');
                        el.classList.add('btn', 'btn-primary');
                    });
                    
                    // Further ensure donation links get primary styling
                    const donateLinks = Array.from(doc.body.querySelectorAll('a'));
                    donateLinks.forEach(a => {
                         const href = (a.getAttribute('href') || '').toLowerCase();
                         if ((href.includes('give.') || href.includes('donate')) && a.classList.contains('btn')) {
                             a.classList.remove('btn-secondary', 'btn-danger'); // Remove other styles
                             a.classList.add('btn', 'btn-primary');
                         }
                    });

                    // Remove .btn-solid (legacy/redundant)
                    const solidBtns = Array.from(doc.body.querySelectorAll('.btn-solid'));
                    solidBtns.forEach(el => el.classList.remove('btn-solid'));

                    // 0.25 CONVERT SALVATION ARMY BACKGROUND COLOR CLASSES TO INLINE STYLES
                    // Map of SA background classes to their colors and text colors
                    const saBgClasses = {
                        'u-sa-whiteBg': { bg: '#ffffff', color: null },
                        'u-sa-blackBg': { bg: '#000000', color: '#ffffff' },
                        'u-sa-greyBg': { bg: '#5a5a5a', color: '#ffffff' },
                        'u-sa-greyLightBg': { bg: '#cccccc', color: null },
                        'u-sa-greyVeryLightBg': { bg: '#f5f5f5', color: null },
                        'u-sa-redBg': { bg: '#ed1b2e', color: '#ffffff' },
                        'u-sa-orangeBg': { bg: '#f89728', color: '#ffffff' },
                        'u-sa-goldBg': { bg: '#f8b425', color: null },
                        'u-sa-creamBg': { bg: '#f5f1e8', color: null },
                        'u-sa-greenBg': { bg: '#00a651', color: '#ffffff' },
                        'u-sa-tealBg': { bg: '#00aeef', color: '#ffffff' },
                        'u-sa-blueLightBg': { bg: '#5eb6e4', color: null },
                        'u-sa-navyBg': { bg: '#002d5a', color: '#ffffff' }
                    };

                    // Find all elements with SA background classes and convert to inline styles
                    Object.keys(saBgClasses).forEach(className => {
                        const elements = Array.from(doc.body.querySelectorAll(`.${className}`));
                        elements.forEach(el => {
                            const colors = saBgClasses[className];
                            const existingStyle = el.getAttribute('style') || '';
                            
                            // Add background color
                            let newStyle = existingStyle;
                            if (!newStyle.includes('background-color')) {
                                newStyle += `${newStyle ? '; ' : ''}background-color: ${colors.bg}`;
                            }
                            
                            // Add text color if specified
                            if (colors.color && !newStyle.includes('color:')) {
                                newStyle += `; color: ${colors.color}`;
                            }
                            
                            el.setAttribute('style', newStyle);
                            el.classList.remove(className); // Remove the class since we've inlined it
                        });
                    });

                    // 0.5 HANDLE WHITE TEXT COLOR
                    // User Request: "update the headings and text inside free text area to use the color white if it is supplied"
                    // We only remove white text if the parent DOES NOT have a background image or dark overlay.
                    // If it DOES have a background, we preserve white and promote it to .text-white for cleaner output.
                    
                    const hasBackground = doc.body.querySelector('[style*="background-image"], [style*="background: url"]') !== null;
                    const hasDarkSection = doc.body.querySelector('.text-white, .bg-dark, .bg-photo-overlay, .bg-primary, .bg-secondary, .bg-info, .bg-danger, .bg-warning, .bg-success') !== null;

                    if (hasBackground || hasDarkSection) {
                        // PROMOTE & PRESERVE: Move white color from spans/styles to Bootstrap classes
                        const blocks = Array.from(doc.body.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li'));
                        blocks.forEach(block => {
                            const whiteSpans = Array.from(block.querySelectorAll('span')).filter(s => {
                                const st = s.getAttribute('style') || '';
                                return /color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))/i.test(st);
                            });

                            const blockStyle = block.getAttribute('style') || '';
                            const isBlockWhite = /color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))/i.test(blockStyle);

                            if (isBlockWhite || whiteSpans.length > 0) {
                                block.classList.add('text-white');
                                
                                // Clean up block inline white
                                if (isBlockWhite) {
                                    const newStyle = blockStyle.replace(/(^|;)\s*color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))\s*(?:!important)?\s*(?:;|$)/gi, '$1');
                                    if (!newStyle.trim() || newStyle.trim() === ';') block.removeAttribute('style');
                                    else block.setAttribute('style', newStyle);
                                }

                                // Clean up child spans white
                                whiteSpans.forEach(s => {
                                    const st = s.getAttribute('style');
                                    const newSt = st.replace(/(^|;)\s*color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))\s*(?:!important)?\s*(?:;|$)/gi, '$1');
                                    if (!newSt.trim() || newSt.trim() === ';') s.removeAttribute('style');
                                    else s.setAttribute('style', newSt);
                                });
                            }
                        });
                    } else {
                        // REMOVE: On white backgrounds, strip white text to ensure visibility
                        const elementsWithStyle = Array.from(doc.body.querySelectorAll('[style*="color"]'));
                        elementsWithStyle.forEach(el => {
                            const style = el.getAttribute('style');
                            if (style) {
                                 const newStyle = style.replace(/(^|;)\s*color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))\s*(?:!important)?\s*(?:;|$)/gi, '$1');
                                 if (newStyle !== style) {
                                     const trimmed = newStyle.trim();
                                     if (!trimmed || trimmed === ';') { el.removeAttribute('style'); }
                                     else { el.setAttribute('style', newStyle); }
                                 }
                            }
                        });
                    }

                    // CLEANUP: Phantom links removal will happen AFTER button unwrapping now (see below)

                    // 1. UNWRAP BUTTONS (Structure Normalization)
                    // Case 1: span.btn > a (Button wrapping link) -> Unwrap outer span
                    const spansWithBtn = Array.from(doc.body.querySelectorAll('span.btn'));
                    spansWithBtn.forEach(span => {
                        const link = span.querySelector('a');
                        if (link) {
                            for (const cls of span.classList) link.classList.add(cls);
                            span.replaceWith(link);
                        }
                    });

                    // Case 2: a ... .btn (Link containing button anywhere inside)
                    // This handles complex nesting like a > strong > span.btn or a > span > span.btn
                    const buttonsInsideLinks = Array.from(doc.body.querySelectorAll('a .btn')); 
                    buttonsInsideLinks.forEach(btnElement => {
                        const link = btnElement.closest('a');
                        if (link) {
                            // Transfer classes
                            for (const cls of btnElement.classList) link.classList.add(cls);
                            
                            // Remove class from child to avoid double-counting
                            btnElement.classList.remove('btn');
                            if(btnElement.classList.length === 0) btnElement.removeAttribute('class');
                            
                            // Un-style the inner span if it was just a button wrapper
                            // Also check for 'style' attribute that might conflict (like color)
                            if (btnElement.tagName === 'SPAN') {
                                // If it's a naked span now, unwrap it
                                if(!btnElement.attributes.length) {
                                     const parent = btnElement.parentNode;
                                     while(btnElement.firstChild) parent.insertBefore(btnElement.firstChild, btnElement);
                                     btnElement.remove();
                                }
                            }
                        }
                    });

                    // 2b. REMOVE PHANTOM CARDS
                    // "I am seeing more cards active on this page than there should be"
                    // Check for cards with empty content or just whitespace/placeholders
                    const cards = Array.from(doc.body.querySelectorAll('.col.mb-4 .card'));
                    cards.forEach(card => {
                        const title = card.querySelector('.card-title')?.textContent?.trim() || '';
                        const textBody = card.querySelector('.card-text');
                        const text = textBody?.textContent?.replace(/\u00a0/g, ' ').trim() || '';
                        const hasImg = card.querySelector('img'); // Look in the whole card, not just textBody

                        // Condition: No image AND no title AND (no text OR text is just punctuation like ".")
                        // If it has an image, it's a gallery card. If it has a title, it's a valid card.
                        if (!hasImg && !title && (!text || text === '.' || text.length < 2)) {
                             // Remove the column container
                             const col = card.closest('.col.mb-4');
                             if (col) col.remove();
                        }
                    });

                    // 3. CLEANUP SPANS & PHANTOM LINKS
                    // User request: "The middle a element with the background color and no text or a space... is a phantom button"
                    // We run this AFTER unwrapping buttons so we catch newly exposed empty links.
                    const allLinks = Array.from(doc.body.querySelectorAll('a'));
                    allLinks.forEach(link => {
                        // Normalize text: handle &nbsp; and trimming
                        const text = (link.textContent || '').replace(/\u00a0/g, ' ').trim();
                        // Check for significant children (img, icons, divs). Note: 'span.btn' should be gone now.
                        const hasMedia = link.querySelector('img, svg, i.icon, span.material-symbols-outlined, div');
                        
                        if (!text && !hasMedia) {
                             link.remove();
                        }
                    });

                    // Remove inline styles from spans that are just wrappers, especially those setting font-family or font-size
                    // User request: "Remove extra span styles that adjust the font-size and or font-family"
                    const stylizedSpans = Array.from(doc.body.querySelectorAll('span[style]'));
                    stylizedSpans.forEach(span => {
                        // Skip Material Symbols icons so their custom font-sizes (e.g. for scaling) are preserved for later processing
                        // Robust check: classList or attribute string check for "material-symbols-outlined"
                        const isIcon = span.classList.contains('material-symbols-outlined') || 
                                       (span.getAttribute('class') || '').includes('material-symbols-outlined');
                        if (isIcon) return;

                        // Check if it has font-size or font-family
                        const style = span.getAttribute('style') || '';
                        if (style.includes('font-size') || style.includes('font-family')) {
                             // Option 1: Remove specific properties (safer)
                             span.style.fontFamily = '';
                             span.style.fontSize = '';
                             
                             // If style is now empty, remove attribute
                             if (!span.getAttribute('style')) {
                                span.removeAttribute('style');
                             }
                             
                             // Optional: if span has no classes or id and no style, unwrap it entirely?
                             // This helps clean up deeply nested spans like <span><span><span>Text</span></span></span>
                             if (span.classList.length === 0 && !span.id && !span.getAttribute('style')) {
                                 const parent = span.parentNode;
                                 while (span.firstChild) {
                                     parent.insertBefore(span.firstChild, span);
                                 }
                                 parent.removeChild(span);
                             }
                        }
                    });

                    // 4. IMAGE ALIGNMENT (User request: default to left if not centered)
                    const allImages = Array.from(doc.body.querySelectorAll('img'));
                    allImages.forEach(img => {
                        // Skip images that are already part of a recognized layout (like cards or carousels)
                        if (img.closest('.card, .carousel-item')) return;

                        const parent = img.parentElement;
                        // Check if it's the "Lone Content" of its block parent
                        // (Legacy CMS behavior: if an image is in its own paragraph, it's usually intended to be centered)
                        const isLoneContent = parent && 
                                             (parent.tagName === 'P' || parent.tagName === 'DIV' || parent.tagName === 'CENTER') &&
                                             (parent.textContent.trim().length === 0) &&
                                             (parent.querySelectorAll('img, video, iframe').length === 1);

                        // Check for explicit left-alignment intent (Bootstrap classes or legacy align attribute)
                        const hasLeftAlignment = img.classList.contains('float-start') || 
                                                 img.classList.contains('me-auto') ||
                                                 img.getAttribute('align') === 'left' ||
                                                 (parent && (parent.classList.contains('text-start') || parent.style.textAlign === 'left' || parent.getAttribute('align') === 'left'));

                        const hasCentering = img.classList.contains('text-center') || 
                                             img.classList.contains('mx-auto') || 
                                             (img.style.textAlign === 'center') ||
                                             (parent && (parent.classList.contains('text-center') || parent.style.textAlign === 'center' || parent.getAttribute('align') === 'center'));
                        
                        const hasAlignment = hasLeftAlignment || img.style.float || img.classList.contains('float-end') || 
                                             img.getAttribute('align') || (parent && (parent.style.textAlign || parent.getAttribute('align')));

                        if (isLoneContent && !hasAlignment) {
                            // Automatically center "Lone" images in paragraphs unless they have explicit alignment
                            img.className += ' d-block mx-auto mb-3';
                            img.style.display = 'block';
                            img.style.marginLeft = 'auto';
                            img.style.marginRight = 'auto';
                        } else if (!hasCentering && !hasAlignment) {
                            // Default to left alignment for other free-floating images
                            img.style.display = 'block';
                            img.style.marginLeft = '0';
                            img.style.marginRight = 'auto';
                        }
                        
                        // FIX: Remove fixed width/height to prevent mobile stretching/compression
                        // If image has both width and height in inline styles, convert to responsive pattern
                        const hasFixedWidth = img.style.width && /^\d+(\.\d+)?px$/.test(img.style.width);
                        const hasFixedHeight = img.style.height && /^\d+(\.\d+)?px$/.test(img.style.height);
                        
                        if (hasFixedWidth || hasFixedHeight) {
                            // Capture original height value before clearing
                            const heightValue = hasFixedHeight ? parseFloat(img.style.height) : 0;
                            
                            // Replace with responsive pattern: max-width 100%, auto width, preserve aspect ratio
                            img.style.maxWidth = '100%';
                            img.style.width = 'auto';
                            
                            // Remove fixed height - let aspect ratio determine it naturally
                            img.style.height = '';
                            
                            // Add max-height for very tall images to prevent excessive vertical space
                            // Use the original height as a guide if available, but cap at reasonable value
                            if (heightValue > 0) {
                                img.style.maxHeight = `${Math.min(heightValue, 500)}px`;
                            } else {
                                img.style.maxHeight = '500px';
                            }
                            
                            // Add object-fit to ensure proper scaling
                            img.style.objectFit = 'contain';
                        }
                    });

                    // Enforce single H1 rule: Keep first H1, convert subsequent H1s to H2s
                    const h1Elements = Array.from(doc.body.querySelectorAll('h1'));
                    if (h1Elements.length > 1) {
                         // Skip the first one (index 0), convert the rest
                         for (let i = 1; i < h1Elements.length; i++) {
                             const h1 = h1Elements[i];
                             const h2 = doc.createElement('h2');
                             // Preserve inner content and IDs/Classes
                             h2.innerHTML = h1.innerHTML;
                             Array.from(h1.attributes).forEach(attr => {
                                 h2.setAttribute(attr.name, attr.value);
                             });
                             h1.replaceWith(h2);
                         }
                    }

                    // Replace legacy icons with Google Material Icons
                    const legacyIcons = Array.from(doc.body.querySelectorAll('i.icon'));
                    legacyIcons.forEach(icon => {
                         const classes = Array.from(icon.classList);
                         // Find specific icon class (e.g. icon-center-heart)
                         const iconClass = classes.find(c => c.startsWith('icon-') && c !== 'icon');
                         
                         let materialName = '';
                         // Map legacy classes to Material Symbols
                         const iconMap = {
                             'icon-center-heart': 'favorite',
                             'icon-shelter': 'night_shelter',
                             'icon-assistpeople': 'handshake',
                             'icon-airline': 'flight',
                             'icon-planned-giving': 'volunteer_activism',
                             'icon-donate-money': 'monetization_on',
                             'icon-donate-goods': 'checkroom',
                             'icon-board': 'groups',
                             'icon-groups': 'groups',
                             'icon-bars': 'bar_chart',
                             'icon-bar-chart': 'bar_chart',
                             'icon-history': 'history_edu',
                             'icon-laptop': 'laptop',
                             'icon-mobile': 'smartphone',
                             'icon-car': 'directions_car'
                         };
                         materialName = iconMap[iconClass] || '';
                         
                         if (materialName) {
                             const span = doc.createElement('span');
                             // Use standard feature icon size (9em) as requested
                             span.className = 'material-symbols-outlined';
                             span.style.fontSize = '9em';
                             span.style.verticalAlign = 'middle';
                             span.textContent = materialName;

                             // Add mb-5 if it's within a card (consistent with other feature icons)
                             if (icon.closest('.card')) {
                                span.classList.add('mb-5');
                             }

                             // Preserve extra classes if any (e.g. text colors)
                             classes.forEach(c => {
                                 if (c !== 'icon' && !c.startsWith('icon-')) {
                                     span.classList.add(c);
                                 }
                             });
                             icon.replaceWith(span);
                         }
                    });

                    // Standardize all Material Symbols for consistency (feature icons)
                    const materialSymbols = Array.from(doc.body.querySelectorAll('.material-symbols-outlined, [class*="material-symbols-outlined"]'));
                    materialSymbols.forEach(span => {
                        // Skip small icons likely used in controls/headers (like carousel arrows with fs-3)
                        if (span.classList.contains('fs-3') || span.closest('button') || span.closest('.header-controls')) return;

                        // Identify icons that are likely "feature" icons (in cards, or specifically known feature icons)
                        const inCard = span.closest('.card');
                        const isKnownFeatureIcon = ['monetization_on', 'currency_bitcoin', 'checkroom', 'groups', 'bar_chart', 'volunteer_activism', 'shelter', 'handshake', 'flight', 'history_edu', 'laptop', 'smartphone'].includes(span.textContent.trim());
                        
                        // Use getAttribute('style') to check for font-size if .style.fontSize is unreliable in parser
                        const styleAttr = span.getAttribute('style') || '';
                        const alreadyScaled = styleAttr.includes('font-size') && styleAttr.includes('em');

                        if (inCard || isKnownFeatureIcon || alreadyScaled) {
                             span.style.fontSize = '9em';
                             span.style.verticalAlign = 'middle';
                             
                             // Consistency fix: add mb-5 if missing when in a card
                             if (inCard && !span.classList.contains('mb-5')) {
                                 span.classList.add('mb-5');
                             }
                        }
                    });

                    // Remove fixed heights from divs that can cause text overlap
                    // These are often legacy layout helpers that restrict content flow
                    const divsWithHeight = Array.from(doc.body.querySelectorAll('div[style*="height:"], div[style*="height :"]'));
                    divsWithHeight.forEach(div => {
                        const style = div.getAttribute('style') || '';
                        // Only remove fixed pixel heights, not min-height or percentage heights
                        if (/height\s*:\s*\d+px/i.test(style)) {
                            const newStyle = style.replace(/height\s*:\s*\d+px\s*;?/gi, '').trim();
                            if (newStyle) {
                                div.setAttribute('style', newStyle);
                            } else {
                                div.removeAttribute('style');
                            }
                        }
                    });

                    const buttons = doc.body.querySelectorAll('.btn');
                    // Add 'btn-white' to removal list to prevent white-on-white buttons
                    const colorClassesToRemove = ['btn-red', 'btn-grey', 'btn-solid', 'btn-navy', 'btn-blueLight', 'btn-teal', 'btn-default', 'btn-primary', 'btn-secondary', 'btn-info', 'btn-danger', 'btn-warning', 'btn-success', 'btn-dark', 'btn-light', 'btn-white'];

                    // Helper to clear existing styling
                    const clearBtnStyles = (btn) => {
                         btn.classList.remove(...colorClassesToRemove);
                         
                         // Clear inline background-color which might override our classes (Fix for invisible buttons)
                         if (btn.style.backgroundColor) {
                             btn.style.backgroundColor = '';
                         }
                         
                         // Fix for "gold text": Remove inline colors from button or children
                         // Specifically looks for spans with inline color: #f8991d
                         const coloredChildren = btn.querySelectorAll('[style*="color"]');
                         coloredChildren.forEach(child => {
                             child.style.color = ''; 
                             if (!child.getAttribute('style')) child.removeAttribute('style');
                         });

                         // Also clean up style attribute if empty
                         if (!btn.getAttribute('style')) btn.removeAttribute('style');

                         // Fix for "bold text": Remove strong/b tags within buttons
                         const boldTags = btn.querySelectorAll('strong, b');
                         boldTags.forEach(bold => {
                             // Unwrap (move children up)
                             const parent = bold.parentNode;
                             while(bold.firstChild) parent.insertBefore(bold.firstChild, bold);
                             bold.remove();
                         });

                         // Also clear font-weight styles
                         if (btn.style.fontWeight) btn.style.fontWeight = '';
                         btn.querySelectorAll('[style*="font-weight"]').forEach(el => {
                             el.style.fontWeight = '';
                             if (!el.getAttribute('style')) el.removeAttribute('style');
                         });

                         // Ensure my-2 is always present (updated from mt-2)
                         btn.classList.remove('mt-2'); 
                         if (!btn.classList.contains('my-2')) btn.classList.add('my-2');
                         
                         // Add horizontal spacing (mx-1)
                         // Note: mx-1 adds 0.25rem margin to left and right.
                         // If user feels this is "too wide" (0.5rem gap), we can't easily go smaller with standard classes without removing it.
                         // But invisible phantom buttons masquerading as gaps are the likely culprit.
                         if (!btn.classList.contains('mx-1')) btn.classList.add('mx-1');
                    };

                    // Group buttons by parent to determine siblings
                    const btnMap = new Map();
                    buttons.forEach(btn => {
                        // Phantom Check (Redundant but safe)
                        if (!btn.textContent.replace(/\u00a0/g, ' ').trim() && !btn.querySelector('img')) {
                             return;
                        }

                        let parent = btn.parentNode;
                        // Special Handling: If parent is a non-block wrapper (like strong, b, em), move up to find real container
                        // This fixes the grouping when buttons are wrapped in <strong> tags
                        while (parent && ['STRONG', 'B', 'EM', 'SPAN', 'I'].includes(parent.tagName)) {
                            parent = parent.parentNode;
                        }

                        if (parent) {
                            if (!btnMap.has(parent)) {
                                btnMap.set(parent, []);
                            }
                            btnMap.get(parent).push(btn);
                        }
                    });

                    // Clean whitespace and apply styles
                    btnMap.forEach((groupBtns, parent) => {
                         // 1. Whitespace Cleanup
                         // Remove text nodes that are direct children of the parent and consist only of whitespace
                         // This ensures that the margins (mx-1) are the ONLY thing creating space between buttons.
                         const childNodes = Array.from(parent.childNodes);
                         childNodes.forEach(node => {
                            if (node.nodeType === 3 && !node.textContent.trim()) {
                                node.remove();
                            }
                         });

                         const count = groupBtns.length;
                         
                         // 2. Button Styling Logic
                         if (count > 2) {
                            // Case: More than 2 buttons -> All Navy
                            groupBtns.forEach(btn => {
                                 clearBtnStyles(btn);
                                 btn.classList.add('btn-secondary');
                                 // btn.classList.add('text-white'); // btn-secondary usually implies white text, add if needed
                            });
                         } else if (count === 2) {
                            // Case: Exactly 2 buttons -> First Blue (info), Second Navy (secondary)
                            // User request: "they should all be btn btn-info since they are next to a second button"
                            const btn1 = groupBtns[0];
                            const btn2 = groupBtns[1];
                            
                            clearBtnStyles(btn1);
                            btn1.classList.add('btn', 'btn-info'); 
                            // Note: btn-info might need text adjustment depending on theme, but user asked for class specifically
                            // Often paired with text-white if background is dark cyan
                            btn1.classList.add('text-white'); 
                            
                            clearBtnStyles(btn2);
                            btn2.classList.add('btn', 'btn-secondary'); 
                         } else {
                            // Case: 1 button
                            const btn = groupBtns[0];
                            clearBtnStyles(btn);
                            
                            // Check href for 'give'
                            const link = (btn.tagName === 'A') ? btn : btn.querySelector('a');
                            const href = (link?.getAttribute('href') || '').toLowerCase();
                            
                            if (href.includes('give.') || href.includes('//give.') || href.includes('give/') || href.includes('donate')) {
                                btn.classList.add('btn', 'btn-primary');
                            } else {
                                btn.classList.add('btn', 'btn-secondary');
                            }
                         }
                    });

                    // Final pass: Ensure styling consistency and remove text decoration
                    buttons.forEach(btn => {
                        // Apply white text to the button itself if it's an anchor, or the child anchor
                        if (btn.tagName === 'A') {
                            if (!btn.classList.contains('text-white')) btn.classList.add('text-white');
                            if (!btn.style.textDecoration) btn.style.textDecoration = 'none';
                        } else {
                            const a = btn.querySelector('a');
                            if (a) {
                                if (!a.classList.contains('text-white')) a.classList.add('text-white');
                                if (!a.style.textDecoration) a.style.textDecoration = 'none';
                            }
                        }
                    });

                    // Fix for centered images in paragraphs
                    // Transform <p style="text-align: center">...</p> to allow centering of images and other inline blocks
                    // Instead of display:block + margin:auto on the image (which forces it to its own line), 
                    // we ensure the image respects the text-align: center of the parent by being inline-block or inline.
                    const centeredParas = doc.body.querySelectorAll('p[style*="text-align: center"], p[style*="text-align:center"]');
                    centeredParas.forEach(p => {
                        const imgs = p.querySelectorAll('img');
                        imgs.forEach(img => {
                            if (img.classList.contains('responsive')) {
                                // Specific request: ensure responsive images in centered paragraphs stay centered
                                // Using display: inline-block allows text-align: center on parent to work
                                img.style.display = 'inline-block';
                            } else {
                                // Default behavior for other images to ensure they don't force left-align via block
                                img.style.display = 'inline-block';
                            }
                        });
                        // Other elements inside the centered P should also naturally center due to text-align: center on P
                    });

                    // --- TRANSFORMATION: HEADING IMAGE CLEANUP ---
                    // Handle images inside headings or paragraphs that are just wrappers for the image
                    doc.body.querySelectorAll('h1, h2, h3, h4, h5, h6, p').forEach(el => {
                        // Check if element contains only an image (and maybe whitespace)
                        const imgs = el.querySelectorAll('img');
                        if (imgs.length === 1 && el.textContent.trim() === '') {
                             const img = imgs[0];
                             // Apply bootstrap centering: d-block mx-auto
                             img.classList.add('d-block', 'mx-auto', 'mb-3');
                             
                             // Remove inline styles that might conflict or are legacy
                             // Keep src, alt. 
                             // If style was "display: block; margin: auto", we are replacing it with classes.
                             // But let's respect existing width/height if needed, or clear them if they break responsiveness.
                             img.style.display = ''; 
                             img.style.marginLeft = '';
                             img.style.marginRight = '';
                             
                             // Unwrap: Insert image before element, then remove element
                             el.parentNode.insertBefore(img, el);
                             el.remove();
                        }
                    });

                    // --- TRANSFORMATION: DEDUPLICATE CARD TITLES ---
                    // If a card-title text matches a heading inside card-body, remove the heading
                    doc.body.querySelectorAll('.card').forEach(card => {
                        // Force card to always have h-100 for equal height
                        card.classList.add('h-100');
                        const cardTitle = card.querySelector('.card-title');
                        const cardBody = card.querySelector('.card-body');
                        // Force card-body to always have d-flex flex-column h-100 only
                        if (cardBody) {
                            cardBody.className = 'card-body d-flex flex-column h-100 p-5';
                        }
                        // Add h-100 to .flex-grow-1 and .rowTop, and set .rowTop to d-flex flex-column h-100 w-100 align-items-stretch
                        if (cardBody) {
                            const fg1 = cardBody.querySelector('.flex-grow-1');
                            if (fg1) fg1.classList.add('h-100');
                            const rowTop = cardBody.querySelector('.rowTop');
                            if (rowTop) rowTop.classList.add('d-flex', 'flex-column', 'h-100', 'w-100', 'align-items-stretch');
                        }
                        
                        if (cardTitle && cardBody) {
                             const titleText = cardTitle.textContent.trim();
                             if (!titleText) return;

                             // Helper: Simple Levenshtein distance for fuzzy matching
                             const getEditDistance = (a, b) => {
                                 if(a.length === 0) return b.length; 
                                 if(b.length === 0) return a.length;
                                 const matrix = [];
                                 for(let i=0; i<=b.length; i++) matrix[i] = [i];
                                 for(let j=0; j<=a.length; j++) matrix[0][j] = j;
                                 for(let i=1; i<=b.length; i++){
                                     for(let j=1; j<=a.length; j++){
                                         if(b.charAt(i-1) === a.charAt(j-1)){
                                             matrix[i][j] = matrix[i-1][j-1];
                                         } else {
                                             matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1));
                                         }
                                     }
                                 }
                                 return matrix[b.length][a.length];
                             };

                             // Normalize string: lowercase, remove non-alphanumeric
                             const normalize = (s) => s.toLowerCase().replace(/[^a-z0-9]/g, '');
                             const normTitle = normalize(titleText);

                             // Find headings AND paragraphs in body (sometimes P tags are used as headings)
                             const headings = cardBody.querySelectorAll('h1, h2, h3, h4, h5, h6, p');
                             headings.forEach(h => {
                                 // Prevent removing the card title itself if it's inside the body
                                 if (h.isSameNode(cardTitle)) return;
                                 
                                 const hText = h.textContent.trim();
                                 if (!hText) return;
                                 
                                 // Safety: If element is very long, it's body text, not a heading duplicate
                                 if (hText.length > titleText.length * 3) return;

                                 const normH = normalize(hText);
                                 if (!normH) return;

                                 // Case 1: Fuzzy match (allow ~25% diff for typos/minor variations)
                                 const dist = getEditDistance(normTitle, normH);
                                 const maxLen = Math.max(normTitle.length, normH.length);
                                 
                                 if (maxLen > 0 && (dist / maxLen) < 0.25) {
                                     // If the heading is actually longer/better, promote it to the card title
                                     if (hText.length > titleText.length) {
                                         cardTitle.textContent = hText;
                                     }
                                     h.remove(); 
                                 } 
                                 // Case 2: Prefix promotion (e.g. Title: "Toy Drive", Heading: "Toy Drives & Donations")
                                 // We promote the heading text to the card title and remove the redundant item.
                                 else if (normH.startsWith(normTitle)) {
                                     cardTitle.textContent = hText;
                                     h.remove();
                                 }
                             });
                        }

                        // --- STRICT BUTTON ROW ALIGNMENT FIX ---
                        // Remove align-items-center and text-center from card-body for button alignment
                        // (already removed by above, but keep for safety)
                        if (cardBody) cardBody.classList.remove('align-items-center', 'text-center');
                        // Remove all legacy and Bootstrap 4 button width/align classes from all buttons
                        const cardBtns = cardBody.querySelectorAll('a.btn, button.btn');
                        if (cardBtns.length > 0) {
                            // Remove all existing .rowBtn containers
                            cardBody.querySelectorAll('.rowBtn').forEach(rb => rb.remove());
                            // Remove btn-block, d-block, mt-auto, and any inline width from all buttons
                            cardBtns.forEach(btn => {
                                btn.classList.remove('btn-block', 'd-block', 'mt-auto', 'align-self-center', 'align-self-end', 'align-self-start');
                                btn.style.width = '';
                                btn.classList.add('w-100');
                            });
                            // Create a new .rowBtn
                            const rowBtn = document.createElement('div');
                            rowBtn.className = 'rowBtn mt-auto w-100 ' + (cardBtns.length > 1 ? 'd-flex' : 'd-block');
                            // Move all buttons into rowBtn
                            cardBtns.forEach(btn => {
                                rowBtn.appendChild(btn);
                            });
                            // --- WRAP ALL NON-rowBtn CONTENT IN .flex-grow-1 ---
                            // Collect all children except .rowBtn
                            const nonBtnNodes = [];
                            Array.from(cardBody.childNodes).forEach(node => {
                                if (!(node.nodeType === 1 && node.classList.contains('rowBtn'))) {
                                    nonBtnNodes.push(node);
                                }
                            });
                            if (nonBtnNodes.length > 0) {
                                const flexGrowDiv = document.createElement('div');
                                flexGrowDiv.className = 'flex-grow-1 w-100';
                                nonBtnNodes.forEach(node => flexGrowDiv.appendChild(node));
                                // Remove all nonBtnNodes from cardBody
                                nonBtnNodes.forEach(node => cardBody.removeChild(node));
                                // Insert flexGrowDiv at the start
                                cardBody.insertBefore(flexGrowDiv, cardBody.firstChild);
                            }
                            // Remove any trailing whitespace or empty nodes at the end
                            while (cardBody.lastChild && (cardBody.lastChild.nodeType === 3 || (cardBody.lastChild.nodeType === 1 && cardBody.lastChild.textContent.trim() === ''))) {
                                cardBody.removeChild(cardBody.lastChild);
                            }
                            // Append rowBtn as the last child
                            cardBody.appendChild(rowBtn);
                        }
                    });

                    // --- TRANSFORMATION: Convert u-hasBgImage sections ---
                    // "Convert it to a div with an image background with a div inside it with the content that appears on top of the image."
                    const bgSections = doc.body.querySelectorAll('.u-hasBgImage');
                    bgSections.forEach(el => {
                        // Create wrapper div
                        const wrapper = doc.createElement('div');
                        
                        // Transfer background styles from inline style
                        if (el.style.backgroundImage) {
                            wrapper.style.backgroundImage = el.style.backgroundImage;
                        }
                        
                        // Setup wrapper styles
                        wrapper.style.backgroundSize = 'cover';
                        wrapper.style.backgroundPosition = 'center';
                        wrapper.style.minHeight = '500px'; 
                        
                        // Base classes: relative for positioning, d-flex for alignment support, TEXT WHITE
                        wrapper.className = 'position-relative d-flex w-100 p-5 mb-3 text-white';

                        // Handle Alignment Classes
                        // "u-verticalAlign and u-textCenter means center"
                        const hasVertical = el.classList.contains('u-verticalAlign');
                        const hasCenter = el.classList.contains('u-textCenter');

                        if (hasVertical) {
                            wrapper.classList.add('align-items-center');
                        }
                        if (hasCenter) {
                            wrapper.classList.add('justify-content-center', 'text-center');
                        }

                        // Use an inner div for content to sit on top of background
                        const inner = doc.createElement('div');
                        // If justify-content-center is used on parent, inner div usually needs to handle width carefully.
                        // But for "centered text on image", usually we just want the flow.
                        inner.className = 'position-relative z-1 content-inner';
                        
                        // Move children
                        while (el.firstChild) {
                            inner.appendChild(el.firstChild);
                        }

                        wrapper.appendChild(inner);
                        el.replaceWith(wrapper);
                    });

                    // --- TRANSFORMATION: Clean up hidden pictures and redundant elements ---
                    const hiddenPics = doc.body.querySelectorAll('picture[style*="display: none"], picture[style*="display:none"], span[style*="display: none"]');
                    hiddenPics.forEach(el => el.remove());

                    // --- TRANSFORMATION: Fix Base64 Images ---
                    const base64Imgs = doc.body.querySelectorAll('img[data-src^="data:image"]');
                    base64Imgs.forEach(img => {
                         const dataSrc = img.getAttribute('data-src');
                         if (dataSrc) {
                             img.setAttribute('src', dataSrc);
                             img.removeAttribute('data-src'); 
                             img.classList.remove('lazyload');
                             img.classList.add('d-block', 'mx-auto'); // Center the image
                         }
                    });

                    // --- TRANSFORMATION: Autolink Phone Numbers and Emails ---
                    // Walk text nodes to find and linkify plain text emails and phones
                    try {
                        const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null);
                        const textNodes = [];
                        while(walker.nextNode()) textNodes.push(walker.currentNode);

                        textNodes.forEach(node => {
                            // Skip if already inside an anchor
                            if (node.parentNode.tagName === 'A' || node.parentNode.closest('a')) return;
                            // Skip scripts/styles
                            if (node.parentNode.tagName === 'SCRIPT' || node.parentNode.tagName === 'STYLE') return;

                            let text = node.nodeValue;
                            if (!text || text.length < 5) return;

                            // Email Regex
                            const emailRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6})/g;
                            // Phone Regex: (XXX) XXX-XXXX or XXX-XXX-XXXX or XXX.XXX.XXXX
                            // Capture groups: 1=Area, 2=Prefix, 3=Line
                            const phoneRegex = /(?:\+?1[-.\s]?)?\(?([2-9][0-8][0-9])\)?[-.\s]?([2-9][0-9]{2})[-.\s]?([0-9]{4})/g;

                            if (emailRegex.test(text) || phoneRegex.test(text)) {
                                // Reset regexes
                                emailRegex.lastIndex = 0;
                                phoneRegex.lastIndex = 0;

                                let newHtml = text
                                    .replace(/&/g, "&amp;")
                                    .replace(/</g, "&lt;")
                                    .replace(/>/g, "&gt;")
                                    .replace(emailRegex, '<a href="mailto:$1">$1</a>')
                                    .replace(phoneRegex, (match, p1, p2, p3) => {
                                        return `<a href="tel:${p1}${p2}${p3}">${match}</a>`;
                                    });

                                if (newHtml !== text) {
                                    const span = doc.createElement('span');
                                    span.innerHTML = newHtml;
                                    // Replace text node with new DOM nodes
                                    if (node.parentNode) {
                                        while (span.firstChild) {
                                            node.parentNode.insertBefore(span.firstChild, node);
                                        }
                                        node.parentNode.removeChild(node);
                                    }
                                }
                            }
                        });
                    } catch (e) {
                        console.warn('Autolink failed', e);
                    }

                     // --- TRANSFORMATION: FreeText Grid & Utility Mapping ---
                     // ".btgrid" -> ".container-fluid"
                    const btgrids = doc.body.querySelectorAll('.btgrid');
                    btgrids.forEach(el => { el.classList.remove('btgrid'); el.classList.add('container-fluid', 'p-0'); });

                    // ".u-textCenter" -> ".text-center"
                    const textCenters = doc.body.querySelectorAll('.u-textCenter');
                    textCenters.forEach(el => { el.classList.remove('u-textCenter'); el.classList.add('text-center'); });

                    // Padding/Margin Mappings
                    const utilityMap = {
                        'padding-top-xl': 'pt-5',
                        'padding-bottom-xl': 'pb-5',
                        'margin-bottom-xl': 'mb-5',
                        'margin-top-xl': 'mt-5',
                        'padding-top-lg': 'pt-4',
                        'padding-bottom-lg': 'pb-4',
                        'margin-bottom-lg': 'mb-4',
                        'margin-top-lg': 'mt-4'
                    };

                    for (const [oldClass, newClass] of Object.entries(utilityMap)) {
                        doc.body.querySelectorAll('.' + oldClass).forEach(el => {
                            el.classList.remove(oldClass);
                            el.classList.add(newClass);
                        });
                    }
                    
                    // Col mapping: "col col-md-4 col-sm-12" -> "col-12 col-md-4"
                    // Also handle nested containers in cols which break grids
                    const cols = doc.body.querySelectorAll('[class*="col-"]');
                    cols.forEach(col => {
                        if (col.classList.contains('col-sm-12')) {
                            col.classList.remove('col-sm-12');
                            col.classList.add('col-12');
                        }
                        // Remove generic 'col' if specific exists
                        if (col.classList.contains('col') && (col.className.includes('col-md') || col.className.includes('col-lg'))) {
                             col.classList.remove('col');
                        }

                        // Fix nested containers
                        const nestedContainers = col.querySelectorAll('.container');
                        nestedContainers.forEach(con => {
                            // "Div within col shouldn't be container"
                            con.classList.remove('container');
                            con.classList.add('w-100'); // preserve width
                        });
                    });

                    // --- TRANSFORMATION: Legacy Offsets and GreyBoxes ---
                    // 1. greyBoxes -> bg-area with padding
                    const greyBoxes = doc.body.querySelectorAll('.greyBoxes');
                    greyBoxes.forEach(el => {
                        el.classList.remove('greyBoxes');
                        el.classList.add('bg-area', 'p-5'); 
                        
                        // If it's a row, ensure children are cols if they aren't
                        if (el.classList.contains('row')) {
                           const children = Array.from(el.children);
                           const divs = children.filter(c => c.tagName === 'DIV');
                           const count = divs.length;
                           // Heuristic: If they are .greyBoxes-box but lack col classes, add col-md-X
                           const colSize = count > 0 ? Math.floor(12 / count) : 12;
                           divs.forEach(child => {
                               if (child.classList.contains('greyBoxes-box')) {
                                   child.classList.remove('greyBoxes-box'); 
                                   child.classList.add('p-4', 'h-100', 'bg-white', 'text-center'); // Added bg-white/text-center based on common patterns
                                   
                                   // Only add col classes if none exist
                                   const hasCol = Array.from(child.classList).some(c => c.startsWith('col-'));
                                   if (!hasCol) {
                                       child.classList.add('col-12', `col-md-${colSize}`);
                                   }
                               }
                           });
                        }
                    });

                    // 2. Column Offsets (Bootstrap 3/4 -> Bootstrap 5)
                    // Pattern: col-XX-offset-Y -> offset-XX-Y
                    const offsetCols = doc.body.querySelectorAll('[class*="col-"]');
                    offsetCols.forEach(el => {
                        const classes = Array.from(el.classList);
                        let addedCol12 = false;
                        classes.forEach(cls => {
                            // Match col-{bp}-offset-{num}
                            const match = cls.match(/^col-(sm|md|lg|xl)-offset-(\d+)$/);
                            if (match) {
                                const bp = match[1];
                                const num = match[2];
                                el.classList.remove(cls);
                                el.classList.add(`offset-${bp}-${num}`);
                                
                                // Ensure mobile stacking
                                // If it relies on offset for layout, it implies a column structure. 
                                // On mobile, if no col class exists, it might be auto-width or crash layout.
                                const hasMobileCol = classes.some(c => /^col-\d+$/.test(c) || c === 'col');
                                if (!hasMobileCol && !addedCol12) {
                                    el.classList.add('col-12');
                                    addedCol12 = true;
                                }
                            }
                        });
                    });
                    
                    // --- TRANSFORMATION: u-flexBox to Bootstrap Grid ---
                    // ".u-flexBox" -> ".row"
                    const flexBoxes = doc.body.querySelectorAll('.u-flexBox');
                    flexBoxes.forEach(flexBox => {
                        flexBox.classList.remove('u-flexBox');
                        flexBox.classList.add('row', 'g-4', 'd-flex', 'h-100'); // Add gap and full height
                        
                        if (flexBox.classList.contains('u-flexBox-stretch')) {
                            flexBox.classList.remove('u-flexBox-stretch');
                            flexBox.classList.add('align-items-stretch');
                        }

                        const children = Array.from(flexBox.querySelectorAll('.u-flexChild'));
                        const count = children.length;
                        let colClass = 'col-12'; // Default mobile stack
                        
                        // Determine column size based on count, defaulting to md breakpoint for stacking
                        if (count === 2) colClass += ' col-md-6';
                        else if (count === 3) colClass += ' col-md-4';
                        else if (count === 4) colClass += ' col-md-3';
                        else if (count > 4) colClass += ' col-md'; // Autolayout for many items

                        children.forEach(child => {
                             child.classList.remove('u-flexChild');
                             // The child (originally u-flexChild) is now the Grid Column (COL).
                             // To fix "not linked together" and height issues, we must ensure:
                             // Row = align-items-stretch (default, but enforced by not adding non-stretch alignment)
                             // Col = h-100 (Bootstrap 5 Cols don't need h-100 to stretch, but flex items inside row do)
                             // CARD = h-100 (This is the KEY. The visible card must fill the height of the col)
                             
                             child.classList.add(...colClass.split(' '));
                             
                             // Clean legacy margins
                             child.classList.remove('margin-right-xl', 'margin-left-xl', 'margin-right-lg', 'margin-left-lg');
                             
                             // CREATE THE INNER CARD
                             // We use the 'card' class to ensure standard Bootstrap behaviors.
                             // 'h-100' makes it fill the column height.
                             const inner = doc.createElement('div');
                             inner.className = 'card h-100 border-0 shadow-sm'; // Use border-0 if we use shadow usually, or add border if requested. Keeping sleek.
                             
                             // CREATE CARD BODY
                             // 'card-body' gives padding. 
                             // 'd-flex flex-column' allows pushing buttons to bottom.
                             const body = doc.createElement('div');
                             body.className = 'card-body d-flex flex-column align-items-center text-center p-5'; // increased padding to p-5 for nice look
                             
                             // Move Styling Classes/Concept
                             // We need to detect if the original child had borders/shadows/bg
                             // And apply them to the CARD (inner), not the col.
                             
                             const styleClasses = ['rounded', 'shadow-sm', 'border', 'bg-white', 'u-roundedCorners', 'u-boxShadow', 'u-standardCase'];
                             
                             let hasShadow = false;
                             let hasBorder = false;
                             
                             if (child.classList.contains('u-boxShadow') || child.classList.contains('shadow-sm')) hasShadow = true;
                             if (child.classList.contains('border')) hasBorder = true;

                             // Clean classes from Col
                             styleClasses.forEach(c => child.classList.remove(c));
                             
                             // Apply to Card (inner)
                             if (hasShadow) inner.classList.add('shadow-sm'); // shadow-sm is good
                             if (hasBorder) inner.classList.add('border');
                             else if (hasShadow) inner.classList.add('border'); // Shadow usually implies border in this design system
                             
                             // Move Content
                             while (child.firstChild) {
                                 body.appendChild(child.firstChild);
                             }
                             
                             inner.appendChild(body);
                             child.appendChild(inner);
                        });

                        // Standardize Buttons in the Row
                        // Issue: Some buttons are wrapped in <p>, preventing them from flexing properly (full width).
                        // "2 of the buttons are using block styling... the third doesn't."
                        // Fix: Unwrap buttons from P tags, force w-100, and unify colors.
                        
                        const rowButtons = flexBox.querySelectorAll('.btn');
                        if (rowButtons.length > 0) {
                            let usePrimary = false;
                            
                            // Check for prominent style
                            rowButtons.forEach(btn => {
                                const href = (btn.getAttribute('href') || btn.querySelector('a')?.getAttribute('href') || '').toLowerCase();
                                if (href.includes('give.') || href.includes('//give.') || href.includes('give/')) {
                                    usePrimary = true;
                                }
                            });
                            
                            rowButtons.forEach(btn => {
                                // 1. Unwrap from P if it is the only child (fixes layout inconsistency)
                                const parent = btn.parentNode;
                                if (parent && parent.tagName === 'P') {
                                     // Only unwrap if P is effectively just a wrapper for the button
                                     if (parent.children.length === 1 && parent.textContent.trim() === btn.textContent.trim()) {
                                         parent.replaceWith(btn);
                                     }
                                }

                                // 2. Styles for consistency
                                btn.classList.add('mt-auto'); // Push to bottom
                                btn.classList.add('w-100', 'd-block'); // Force full width block style
                                
                                // 3. Unify colors
                                btn.classList.remove('btn-primary', 'btn-secondary', 'btn-info');
                                if (usePrimary) {
                                    btn.classList.add('btn-primary');
                                } else {
                                    btn.classList.add('btn-secondary');
                                }
                                
                                // 4. Text color
                                if (!btn.classList.contains('text-white')) btn.classList.add('text-white');
                            });
                        }
                    });

                    // --- TRANSFORMATION: Carousels ---
                    // Unwrap from article/bd-example wrappers
                    const carousels = doc.body.querySelectorAll('.carousel');
                    carousels.forEach(carousel => {
                         // Find the outermost wrapper that we want to strip (article)
                         // Structure: article > div > div.bd-example... -> .carousel
                         let wrapper = carousel.closest('article');
                         if (wrapper && wrapper.id.includes('carousel')) {
                              wrapper.replaceWith(carousel);
                         }
                    });


                    // --- TRANSFORMATION: Convert Icons ---
                    // "Convert icons like this to an appropriate google materical icon replacement"
                    const iconMap = {
                        'icon-hearthand-white': { name: 'volunteer_activism', color: 'text-white' },
                        'icon-hearthand': { name: 'volunteer_activism', color: '' },
                        'icon-donate-money': { name: 'monetization_on', color: '' }, // or attach_money
                        'icon-donate-goods': { name: 'checkroom', color: '' },
                        'icon-board': { name: 'groups', color: '' },
                        'icon-bar-chart': { name: 'bar_chart', color: '' },
                        'icon-planned-giving': { name: 'history_edu', color: '' },
                        'icon-search': { name: 'search', color: '' },
                        'icon-check': { name: 'check', color: '' },
                        'icon-cross': { name: 'close', color: '' },
                        'icon-arrow-right': { name: 'arrow_forward', color: '' },
                        'icon-arrow-left': { name: 'arrow_back', color: '' },
                        // FontAwesome mappings
                        'fa-bitcoin': { name: 'currency_bitcoin', color: '' },
                        'fa-car': { name: 'directions_car', color: '' }
                    };

                    const processIcon = (icon) => {
                         let match = null;
                         for (const cls of icon.classList) {
                            // Direct map
                            if (iconMap[cls]) {
                                match = iconMap[cls];
                                break;
                            }
                            // Generic fa- check
                            if (cls.startsWith('fa-') && iconMap[cls]) {
                                match = iconMap[cls];
                                break;
                            }
                         }

                         if (match) {
                            const matIcon = doc.createElement('span');
                            matIcon.className = 'material-symbols-outlined ' + match.color; // Using symbols outlined usually better
                            matIcon.textContent = match.name;
                            matIcon.style.verticalAlign = 'middle';
                            
                            // Handling Icon Sizes:
                            // Priority: 9em for feature icons or cards, then legacy font-size/height
                            let size = '2em';
                            const featureIconsList = ['monetization_on', 'currency_bitcoin', 'checkroom', 'groups', 'bar_chart', 'volunteer_activism', 'shelter', 'handshake', 'flight', 'history_edu', 'laptop', 'smartphone'];
                            
                            if (featureIconsList.includes(match.name) || icon.closest('.card')) {
                                size = '9em';
                            } else {
                                // Fallback FontAwesome size classes
                                if (icon.classList.contains('fa-2x')) size = '2em';
                                else if (icon.classList.contains('fa-3x')) size = '3em';
                                else if (icon.classList.contains('fa-4x')) size = '4em';
                                else if (icon.classList.contains('fa-5x')) size = '5em';
                                else if (icon.classList.contains('fa-10x') || icon.classList.contains('fa-17x')) size = '9em';

                                // Custom inline style priority (if not a feature icon)
                                if (icon.style.fontSize) {
                                    size = icon.style.fontSize;
                                } else if (icon.style.height) {
                                    size = icon.style.height;
                                }
                            }
                            
                            matIcon.style.fontSize = size;
                            
                            // Ensure 9em icons always align middle and have bottom margin in cards
                            if (size === '9em') {
                                matIcon.style.verticalAlign = 'middle';
                                if (icon.closest('.card')) {
                                    matIcon.classList.add('mb-5');
                                }
                            }
                            
                            // Copy margin/padding/color
                            icon.classList.forEach(c => {
                                if (c.startsWith('m-') || c.startsWith('p-') || c.startsWith('me-') || c.startsWith('text-') || c.startsWith('margin-') || c.startsWith('padding-')) {
                                    // map legacy margins
                                    if (c === 'margin-bottom-xl') matIcon.classList.add('mb-5');
                                    else if (c === 'margin-bottom-lg') matIcon.classList.add('mb-4');
                                    else matIcon.classList.add(c);
                                }
                                // Keep color style if inline
                                if (icon.style.color) matIcon.style.color = icon.style.color;
                            });
                            
                            icon.replaceWith(matIcon);
                         }
                    };

                    doc.body.querySelectorAll('i.icon').forEach(processIcon);
                    doc.body.querySelectorAll('i.fab, i.fas, i.far').forEach(processIcon); // Process fontawesome too

                    // --- FIX: Bootstrap Grid Column Overflow ---
                    // If a row has columns that exceed 12 units total, they will wrap.
                    // This fixes cases where 5 columns each have col-md-3 (totaling 15 > 12).
                    // Solution: Use auto-width columns (col-md) for equal distribution.
                    const rows = doc.body.querySelectorAll('.row');
                    rows.forEach(row => {
                        // Get direct children that are columns
                        const cols = Array.from(row.children).filter(el => {
                            return Array.from(el.classList).some(cls => cls.startsWith('col-'));
                        });
                        
                        if (cols.length === 0) return;
                        
                        // Calculate total column units for each breakpoint
                        const breakpoints = ['', 'sm', 'md', 'lg', 'xl', 'xxl'];
                        
                        breakpoints.forEach(bp => {
                            const regex = bp ? new RegExp(`col-${bp}-(\\d+)`) : /^col-(\d+)$/;
                            let total = 0;
                            let hasColumns = false;
                            
                            cols.forEach(col => {
                                Array.from(col.classList).forEach(cls => {
                                    const match = cls.match(regex);
                                    if (match) {
                                        total += parseInt(match[1]);
                                        hasColumns = true;
                                    }
                                });
                            });
                            
                            // If total exceeds 12, convert to auto-width columns
                            if (hasColumns && total > 12) {
                                cols.forEach(col => {
                                    // Remove the oversized column class
                                    Array.from(col.classList).forEach(cls => {
                                        if (regex.test(cls)) {
                                            col.classList.remove(cls);
                                        }
                                    });
                                    
                                    // Add auto-width column class for this breakpoint
                                    if (bp) {
                                        col.classList.add(`col-${bp}`);
                                    } else {
                                        // Base mobile should stay col-12 for stacking
                                        if (!col.classList.contains('col-12')) {
                                            col.classList.add('col-12');
                                        }
                                    }
                                });
                            }
                        });
                    });

                    updated = doc.body.innerHTML;
                } catch (e) {
                    // keep original content if parsing fails
                }
                
                // If this is a freetextarea with a background image, don't use horizontal margins (mx-2)
                // so it can span as wide as possible within the container.
                // Only check property-level background fields (not inline HTML content)
                const hasBackgroundImage = prop && (prop.background || prop.background_image || prop.backgroundImage || prop.heroImage);
                const isBgSection = typeLower.includes('freetextarea') && hasBackgroundImage;
                let wrapperClass = isBgSection ? 'mb-5' : (forCombinedView ? 'mb-5 mx-2' : 'mb-3');
                
                // Add anchor ID if available from the property manifest (prefer document.custom_head_content)
                let anchor = null;
                if (prop) {
                    // Priority 1: Direct extraction from document.custom_head_content
                    anchor = getAnchorFromDocumentManifest(prop);
                    
                    // Priority 2: Fallback to cached manifest entry
                    if (!anchor) {
                        const entry = getManifestPropertyEntry(prop);
                        if (entry) {
                            anchor = (entry.details && (entry.details.anchorLink || entry.details.anchor_link || entry.details.anchor)) ||
                                     entry.anchorLink || entry.anchor_link || entry.anchor || null;
                        }
                    }
                    
                    // Priority 3: Final fallback
                    if (!anchor) {
                        anchor = getCustomPropertyAnchor(prop);
                    }
                    
                    // Debug logging
                    if (anchor) {
                        console.log(`Anchor for property ${prop.id || prop.name}: "${anchor}"`);
                    } else {
                        console.warn(`No anchor found for property:`, prop.id || prop.name, prop.property_type);
                    }
                }
                const idAttr = anchor ? ` id="${escapeHtml(anchor)}"` : '';
                
                // Handle backgroundColor property field - convert SA background classes to inline styles
                let styleAttr = '';
                if (prop && prop.backgroundColor) {
                    const saBgClasses = {
                        'u-sa-whiteBg': { bg: '#ffffff', color: null },
                        'u-sa-blackBg': { bg: '#000000', color: '#ffffff' },
                        'u-sa-greyBg': { bg: '#5a5a5a', color: '#ffffff' },
                        'u-sa-greyLightBg': { bg: '#cccccc', color: null },
                        'u-sa-greyVeryLightBg': { bg: '#f5f5f5', color: null },
                        'u-sa-redBg': { bg: '#ed1b2e', color: '#ffffff' },
                        'u-sa-orangeBg': { bg: '#f89728', color: '#ffffff' },
                        'u-sa-goldBg': { bg: '#f8b425', color: null },
                        'u-sa-creamBg': { bg: '#f5f1e8', color: null },
                        'u-sa-greenBg': { bg: '#00a651', color: '#ffffff' },
                        'u-sa-tealBg': { bg: '#00aeef', color: '#ffffff' },
                        'u-sa-blueLightBg': { bg: '#5eb6e4', color: null },
                        'u-sa-navyBg': { bg: '#002d5a', color: '#ffffff' }
                    };
                    
                    const bgClass = prop.backgroundColor;
                    if (saBgClasses[bgClass]) {
                        // Only apply backgroundColor styles if there's NO background image
                        // Background image always takes precedence over backgroundColor
                        if (!hasBackgroundImage) {
                            const styles = [];
                            styles.push(`background-color: ${saBgClasses[bgClass].bg}`);
                            if (saBgClasses[bgClass].color) {
                                styles.push(`color: ${saBgClasses[bgClass].color}`);
                            }
                            styleAttr = ` style="${styles.join('; ')}"`;
                            
                            // Add rounded + overflow-hidden + padding for consistency
                            wrapperClass += ' rounded overflow-hidden p-4';
                        }
                    }
                }
                
                updated = `<div${idAttr} class="${wrapperClass}"${styleAttr}>${updated}</div>`;
            }
            return updated;
        }

                function parseObjectsArray(value) {
                        if (!value) return null;
                        if (Array.isArray(value)) return value;
                        if (typeof value !== 'string') return value;
                        try {
                                let parsed = JSON.parse(value);
                                if (typeof parsed === 'string') {
                                        parsed = JSON.parse(parsed);
                                }
                                return parsed;
                        } catch (e) {
                                return null;
                        }
                }

                function buildAccordionGroupHtml(items, parentId, parentVisible = true) {
                        if (!Array.isArray(items) || items.length === 0) return '';
                        
                        // Filter items: honor parent visibility first, then item active status
                        const activeItems = items.filter(item => {
                            if (!parentVisible) return false;
                            
                            // Check for active/featured/visible status on the item itself
                            // Most common keys: active, featured, visible
                            const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                            const isFeatured = item.featured !== false && item.featured !== 'false' && item.featured !== 0;
                            const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                            
                            // Accordions don't usually use featured, so we only check if explicitly false or if it's a slide
                            return isActive && !hasEnded && isFeatured;
                        });

                        if (activeItems.length === 0) return '';

                        const parent = parentId || `accordion-${items[0]?.id || 'group'}`;
                        const normalizedItems = activeItems.map((item, index) => {
                                const itemId = item?.id || `${index + 1}`;
                                const headingId = `heading-${itemId}`;
                                const collapseId = `collapse-${itemId}`;
                                const title = item?.title || `Item ${index + 1}`;
                                const bodyHtml = item?.html || '';
                                const isExpanded = item?.expanded === true;
                                return `
    <div class="accordion-item">
        <h2 class="accordion-header" id="${headingId}">
            <button class="accordion-button${isExpanded ? '' : ' collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${isExpanded ? 'true' : 'false'}" aria-controls="${collapseId}">
                ${escapeHtml(title)}
            </button>
        </h2>
        <div id="${collapseId}" class="accordion-collapse collapse${isExpanded ? ' show' : ''}" aria-labelledby="${headingId}" data-bs-parent="#${parent}">
            <div class="accordion-body">
                ${bodyHtml}
            </div>
        </div>
    </div>`;
                        }).join('');

                            return `<div class="accordion my-2" id="${parent}">${normalizedItems}
</div>`;
                }


                // Helper: Convert legacy FAQ/Accordion HTML structures to Bootstrap 5 Accordion
                function convertLegacyFaqToAccordion(html, propId) {
                    if (!html || !html.includes('faq-container')) return html;
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    
                    const containers = tempDiv.querySelectorAll('.faq-container');
                    
                    containers.forEach((container, cIdx) => {
                        const items = container.querySelectorAll('.faq-item');
                        if (items.length === 0) return;
                        
                        // Generate a unique ID for the accordion group
                        const shortId = (propId || 'faq' + Math.floor(Math.random()*10000)).toString().replace(/[^a-zA-Z0-9]/g, '').substring(0,8);
                        const accordionId = `accordion-${shortId}-${cIdx}`;
                        
                        // Check for headers inside the container that should be preserved (e.g. <h2>FAQ</h2>)
                        // If they are inside .faq-container but outside .faq-item
                        let preHtml = '';
                        // Move non-item children that are headers to be before the accordion
                        const headers = container.querySelectorAll(':scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > h5, :scope > h6, :scope > p');
                        headers.forEach(h => {
                            // Only capture if it's strictly before the first item or looks like a title
                            // For simplicity, we'll just check if there's a header.
                            if (!h.closest('.faq-item')) {
                                preHtml += h.outerHTML;
                            }
                        });


                        const accordionItems = Array.from(items).map((item, idx) => {
                            const questionEl = item.querySelector('.faq-question');
                            if (!questionEl) return '';
                            
                            // Remove the toggle icon (+/v) from the question text
                            const icon = questionEl.querySelector('.faq-icon');
                            if (icon) icon.remove();
                            
                            // Get standard question text
                            const questionText = questionEl.innerHTML.trim();
                            
                            const answerEl = item.querySelector('.faq-answer');
                            const answerText = answerEl ? answerEl.innerHTML.trim() : '';
                            
                            const uniqueSuffix = `${shortId}-${cIdx}-${idx+1}`;
                            const headingId = `heading-${uniqueSuffix}`;
                            const collapseId = `collapse-${uniqueSuffix}`;
                            const isExpanded = item.classList.contains('open'); // Check original 'open' class
                            
                            return `
                              <div class="accordion-item">
                                <h2 class="accordion-header" id="${headingId}">
                                  <button class="accordion-button${isExpanded ? '' : ' collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${isExpanded ? 'true' : 'false'}" aria-controls="${collapseId}">
                                    ${questionText}
                                  </button>
                                </h2>
                                <div id="${collapseId}" class="accordion-collapse collapse${isExpanded ? ' show' : ''}" aria-labelledby="${headingId}" data-bs-parent="#${accordionId}">
                                  <div class="accordion-body">
                                    ${answerText}
                                  </div>
                                </div>
                              </div>`;
                        }).join('\n');
                        
                        const newHtml = `${preHtml}\n<div class="accordion my-3" id="${accordionId}">\n${accordionItems}\n</div>`;
                        
                        const wrapper = document.createElement('div');
                        wrapper.innerHTML = newHtml;
                        container.replaceWith(...wrapper.childNodes);
                    });
                    
                    return tempDiv.innerHTML;
                }

                function buildPropertySnapshotHtml(prop) {
                    if (!prop) return '';
                    let content = String(prop.text_html || '').trim();
                    
                    // Auto-convert legacy custom FAQ HTML to Bootstrap Accordion
                    if (content.includes('faq-container')) {
                        content = convertLegacyFaqToAccordion(content, prop.id);
                    }

                    const propType = String(prop.property_type || '').toLowerCase();
                    const isVisible = isPropertyActuallyVisible(prop);
                    
                    // 1. Accordions - return actual HTML of items
                    if (propType.includes('accordiongroup')) {
                        const items = parseObjectsArray(prop.objects_array || prop.value);
                        if (Array.isArray(items) && items.length > 0) {
                             // Use a cleaner, shorter ID base to ensure compatibility
                             const shortId = (prop.id || '').replace(/[^a-zA-Z0-9]/g, '').substring(0, 8) || 'acc' + Math.floor(Math.random()*10000);
                             const accordionId = `accordion-${shortId}`;
                             
                             const itemsHtml = items.filter(item => {
                                 const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                                 const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                                 return isActive && !hasEnded;
                             }).map((item, index) => {
                                 const uniqueSuffix = `${shortId}-${index+1}`;
                                 const headingId = `heading-${uniqueSuffix}`;
                                 const collapseId = `collapse-${uniqueSuffix}`;
                                 const title = escapeHtml(item.title || item.heading || `Item ${index+1}`);
                                 const bodyContent = item.content || item.text || item.html || '';
                                 // Check for explicit expanded property (boolean or string 'true')
                                 const isExpanded = (item.expanded === true || String(item.expanded).toLowerCase() === 'true');
                                 
                                 return `
  <div class="accordion-item">
    <h2 class="accordion-header" id="${headingId}">
      <button class="accordion-button${isExpanded ? '' : ' collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${isExpanded ? 'true' : 'false'}" aria-controls="${collapseId}">
        ${title}
      </button>
    </h2>
    <div id="${collapseId}" class="accordion-collapse collapse${isExpanded ? ' show' : ''}" aria-labelledby="${headingId}" data-bs-parent="#${accordionId}">
      <div class="accordion-body">
        ${bodyContent}
      </div>
    </div>
  </div>`;
                             }).join('\n');
                             
                             content = (content ? content + '\n' : '') + `<div class="accordion my-3" id="${accordionId}">\n${itemsHtml}\n</div>`;
                        }
                    }

                    // 2. Slides/Carousels
                    if (propType.includes('slide') || propType.includes('carousel')) {
                        const items = parseObjectsArray(prop.objects_array || prop.value);
                        if (items && items.length > 0) {
                            const slides = parseSlides(items, true);
                            const activeSlides = slides.filter(s => !s.isExpired);
                            if (activeSlides.length > 0) {
                                const carouselId = `carousel-${prop.id}`;
                                const pos = parseInt(prop.position, 10);
                                
                                // Check if user has overridden the hero/carousel decision
                                let isHeroMode = (activeSlides.length === 1 && pos === 1);
                                if (window.heroOverrides && window.heroOverrides.hasOwnProperty(prop.id)) {
                                     isHeroMode = window.heroOverrides[prop.id];
                                }

                                if (isHeroMode) {
                                    // Treated as HERO image.
                                    // Do NOT add to basic content HTML (it should be manually uploaded elsewhere).
                                } else {
                                    // Multiple slides, or single slide treated as Carousel: convert to Bootstrap carousel
                                    // Check if content override is enabled for this property
                                    // Default to TRUE for visibility of content
                                    let includeContent = true;
                                    if (window.slideContentOverrides && window.slideContentOverrides.hasOwnProperty(prop.id)) {
                                         includeContent = window.slideContentOverrides[prop.id];
                                    }

                                    // Determine if ANY slide has a mobile image. 
                                    // NO LONGER USED: We now ALWAYS switch to mobile aspect ratio on mobile screens to ensure content visibility.
                                    // const hasAnyMobileImage = activeSlides.some(s => s.hasMobileImage);

                                    const slidesHtml = activeSlides.map((s, i) => {
                                        // Use s.altText (fallback) for image alt
                                        const altText = s.altText || s.title || '';
                                        
                                        // Filter overlay
                                        const filterClasses = (includeContent && s.filter) ? getFilterClass(s.filter) : '';
                                        // Ensure overlay has lower z-index than caption (which should be 2) but above image.
                                        const overlayHtml = filterClasses ? '<div class="' + filterClasses + '" style="position: absolute; inset: 0; z-index: 1;"></div>' : '';

                                        // ---------------------------------------------------------
                                        // Desktop View Wrapper
                                        // ---------------------------------------------------------
                                        // Always hidden on mobile (d-none d-md-block).
                                        const desktopClass = 'position-relative d-none d-md-block w-100';
                                        const mediaDesktop = renderSlideMedia(s, false);
                                        
                                        // aspect-ratio: 1300/508 ~= 2.559
                                        const wrapperDesktop = '<div class="' + desktopClass + '" style="aspect-ratio: 1300/508; overflow: hidden;">' + mediaDesktop + overlayHtml + '</div>';
                                        
                                        // ---------------------------------------------------------
                                        // Mobile View Wrapper
                                        // ---------------------------------------------------------
                                        // Always shown on mobile (d-block d-md-none).
                                        // Ensures all slides have a 500/425 container on mobile.
                                        const mobileClass = 'position-relative d-block d-md-none w-100';
                                        const mediaMobile = renderSlideMedia(s, true);
                                        
                                        // aspect-ratio: 500/425 ~= 1.176
                                        const wrapperMobile = ' <div class="' + mobileClass + '" style="aspect-ratio: 500/425; overflow: hidden;">' + mediaMobile + overlayHtml + '</div>';

                                        let innerContent = wrapperDesktop + wrapperMobile;
                                        
                                        if (s.theaterImageUrl) {
                                            innerContent = '<a href="' + s.theaterImageUrl + '">' + innerContent + '</a>';
                                        }

                                        let captionHtml = '';
                                        if (includeContent) {
                                            const align = (s.alignment || 'center').toLowerCase();
                                            const alignClass = align === 'right' ? 'text-end' : (align === 'left' ? 'text-start' : 'text-center');
                                            
                                            let buttonsHtml = '';
                                            if (s.showButtons) {
                                                 const btns = [];
                                                 if (s.buttonText && s.buttonUrl) btns.push({text: s.buttonText, url: s.buttonUrl});
                                                 if (s.secondaryButtonText && s.secondaryButtonUrl) btns.push({text: s.secondaryButtonText, url: s.secondaryButtonUrl});
                                                 
                                                 if (btns.length > 0) {
                                                     buttonsHtml = '<div class="slider-btn">';
                                                     if (btns.length === 1) {
                                                         buttonsHtml += `<a href="${btns[0].url}" class="btn btn-secondary">${escapeHtml(btns[0].text)}</a>`;
                                                     } else {
                                                         buttonsHtml += `<a href="${btns[0].url}" class="btn btn-info">${escapeHtml(btns[0].text)}</a> `;
                                                         buttonsHtml += `<a href="${btns[1].url}" class="btn btn-secondary">${escapeHtml(btns[1].text)}</a>`;
                                                     }
                                                     buttonsHtml += '</div>';
                                                 }
                                            }
                                            
                                            if (s.title || s.subtitle || buttonsHtml) {
                                                const titleHtml = (s.title && s.title.match(/<[^>]+>/)) ? s.title : escapeHtml(s.title || '');
                                                const subtitleHtml = (s.subtitle && s.subtitle.match(/<[^>]+>/)) ? s.subtitle : escapeHtml(s.subtitle || '');

                                                captionHtml = `
            <div class="carousel-caption ${alignClass}" style="z-index: 2;">
              ${s.title ? `<h3>${titleHtml}</h3>` : ''}
              ${s.subtitle ? `<p>${subtitleHtml}</p>` : ''}
              ${buttonsHtml}
            </div>`;
                                            }
                                        }

                                        return '<div class="carousel-item ' + (i === 0 ? 'active' : '') + '">' + innerContent + captionHtml + '</div>';
                                    }).join('');

                                    // Format indicators
                                    // We'll wrap these in a position-static div inside our custom control bar
                                    const indicators = activeSlides.map((_, i) => `<button type="button" data-bs-target="#${carouselId}" data-bs-slide-to="${i}" ${i === 0 ? 'class="active" aria-current="true"' : ''} aria-label="Slide ${i + 1}"></button>`).join('\n              ');

                                    const carouselHtml = `<!-- Carousel -->
<article class="my-3" id="carousel-${prop.id}-article">
  <div>
    <div class="bd-example-snippet bd-code-snippet">
      <div class="bd-example m-0 border-0">
        <div
          id="${carouselId}"
          class="carousel slide"
          data-bs-ride="carousel"
        >
          <div class="carousel-inner rounded overflow-hidden">
            ${slidesHtml}
          </div>

          ${activeSlides.length > 1 ? `
          <!-- Custom Control Container: Overlaid at Bottom -->
          <div class="d-flex justify-content-center align-items-center w-100 pb-3" style="position: absolute; bottom: 0; left: 0; z-index: 10; pointer-events: none;">
              
              <!-- Prev Button -->
              <button id="prevBtn-${prop.id}" class="btn btn-link link-light text-decoration-none p-0 mx-3 opacity-75 hover-opacity-100" type="button" data-bs-target="#${carouselId}" data-bs-slide="prev" aria-label="Previous" style="pointer-events: auto; background: transparent !important; border: 0;">
                <span class="material-symbols-outlined fs-3" style="text-shadow: 0 0 2px rgba(0,0,0,0.6);">arrow_back</span>
              </button>

              <!-- Indicators (Dots) -->
              <div id="carouselIndicators-${prop.id}" class="carousel-indicators position-static m-0 mx-2" style="width: auto; pointer-events: auto;">
                ${indicators}
              </div>

              <!-- Next Button -->
              <button id="nextBtn-${prop.id}" class="btn btn-link link-light text-decoration-none p-0 mx-3 opacity-75 hover-opacity-100" type="button" data-bs-target="#${carouselId}" data-bs-slide="next" aria-label="Next" style="pointer-events: auto; background: transparent !important; border: 0;">
                <span class="material-symbols-outlined fs-3" style="text-shadow: 0 0 2px rgba(0,0,0,0.6);">arrow_forward</span>
              </button>
          </div>` : ''}

        </div>
      </div>
    </div>
  </div>
</article>
<!-- JS: Hide indicators and controls immediately after first slide load, show only on hover -->
<script>
  const carousel_${prop.id} = document.getElementById('${carouselId}');
  const indicators_${prop.id} = document.getElementById('carouselIndicators-${prop.id}');
  const prevBtn_${prop.id} = document.getElementById('prevBtn-${prop.id}');
  const nextBtn_${prop.id} = document.getElementById('nextBtn-${prop.id}');

  // Hide immediately after first render
  window.addEventListener('load', () => {
    if(indicators_${prop.id}) indicators_${prop.id}.style.display = 'none';
    if(prevBtn_${prop.id}) prevBtn_${prop.id}.style.display = 'none';
    if(nextBtn_${prop.id}) nextBtn_${prop.id}.style.display = 'none';
  });

  // Show on hover (ONLY if more than 1 slide)
  if(carousel_${prop.id} && ${activeSlides.length} > 1) {
      carousel_${prop.id}.addEventListener('mouseenter', () => {
        if(indicators_${prop.id}) indicators_${prop.id}.style.display = 'flex';
        if(prevBtn_${prop.id}) prevBtn_${prop.id}.style.display = 'flex';
        if(nextBtn_${prop.id}) nextBtn_${prop.id}.style.display = 'flex';
      });

      carousel_${prop.id}.addEventListener('mouseleave', () => {
        if(indicators_${prop.id}) indicators_${prop.id}.style.display = 'none';
        if(prevBtn_${prop.id}) prevBtn_${prop.id}.style.display = 'none';
        if(nextBtn_${prop.id}) nextBtn_${prop.id}.style.display = 'none';
      });
  }
<\/script>`;
                                    content = (content ? content + '\n' : '') + carouselHtml;
                                }
                            }
                        }
                    }

                    // 3. Cards/Tiles/Features - return Bootstrap 5 Grid layout
                    if (propType.includes('card') || propType.includes('tile') || propType.includes('feature')) {
                        let items = parseObjectsArray(prop.objects_array || prop.value);
                        // Filter out inactive items based on 'active' property
                        if (Array.isArray(items)) {
                            items = items.filter(item => {
                                const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                                const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                                return isActive && !hasEnded;
                            });
                        }

                        if (Array.isArray(items) && items.length > 0) {
                            // Check outline override (default true)
                            let hasOutline = true;
                            if (window.cardOutlineOverrides && window.cardOutlineOverrides.hasOwnProperty(prop.id)) {
                                 hasOutline = window.cardOutlineOverrides[prop.id];
                            }
                            const borderClass = hasOutline ? ' border' : '';
                            
                            const cardsCols = items.map(item => {
                                const titleRaw = item.title || item.heading || (item.image || item.imageUrl || item.backgroundImage ? '' : 'Untitled');
                                const title = titleRaw ? escapeHtml(titleRaw) : '';
                                let desc = item.text || item.description || item.html || '';

                                // Clean up empty space elements (e.g. <p>&nbsp;</p>) that are often used in legacy CMS 
                                // to force height for background images. In our viewer, we use <img>, so these are redundant.
                                if (desc) {
                                    // Remove blocks that only contain whitespace, &nbsp;, or <br>
                                    const cleanDesc = desc.replace(/<p[^>]*>\s*(&nbsp;|\s|(<br\s*\/?>))*\s*<\/p>/gi, '').trim();
                                    if (!cleanDesc || cleanDesc === '&nbsp;') {
                                        desc = '';
                                    }
                                    
                                    // Remove duplicate heading that matches the title
                                    // This handles cases where the title appears as an H1-H6 at the start of the description
                                    if (title && desc) {
                                        // Normalize strings for comparison (remove non-alphanumeric, lowercase)
                                        const normalizeStr = (str) => str.replace(/[^a-z0-9]/gi, '').toLowerCase();
                                        const normalizedTitle = normalizeStr(title);
                                        
                                        // Check if description starts with a heading that matches the title (with some flexibility)
                                        const headingMatch = desc.match(/^\s*<h[1-6][^>]*>(.*?)<\/h[1-6]>/i);
                                        if (headingMatch) {
                                            const headingText = headingMatch[1].replace(/<[^>]+>/g, '').trim(); // Strip inner HTML tags
                                            const normalizedHeading = normalizeStr(headingText);
                                            
                                            // If normalized strings are similar (allowing for minor typos/differences)
                                            // Remove the heading if it's at least 70% similar
                                            if (normalizedHeading.length > 0 && normalizedTitle.length > 0) {
                                                const similarity = normalizedHeading === normalizedTitle || 
                                                    (Math.abs(normalizedHeading.length - normalizedTitle.length) <= 2 && 
                                                     normalizedTitle.includes(normalizedHeading.substring(0, Math.floor(normalizedHeading.length * 0.7))));
                                                
                                                if (similarity || normalizedHeading === normalizedTitle) {
                                                    desc = desc.replace(/^\s*<h[1-6][^>]*>.*?<\/h[1-6]>\s*/i, '').trim();
                                                }
                                            }
                                        }
                                    }
                                }

                                const imgUrl = item.image || item.imageUrl || item.background || item.backgroundImage || item.background_image || item.src;
                                
                                // Handle backgroundColor from individual card item
                                const saBgClasses = {
                                    'u-sa-whiteBg': { bg: '#ffffff', color: null },
                                    'u-sa-blackBg': { bg: '#000000', color: '#ffffff' },
                                    'u-sa-greyBg': { bg: '#5a5a5a', color: '#ffffff' },
                                    'u-sa-greyLightBg': { bg: '#cccccc', color: null },
                                    'u-sa-greyVeryLightBg': { bg: '#f5f5f5', color: null },
                                    'u-sa-redBg': { bg: '#ed1b2e', color: '#ffffff' },
                                    'u-sa-orangeBg': { bg: '#f89728', color: '#ffffff' },
                                    'u-sa-goldBg': { bg: '#f8b425', color: null },
                                    'u-sa-creamBg': { bg: '#f5f1e8', color: null },
                                    'u-sa-greenBg': { bg: '#00a651', color: '#ffffff' },
                                    'u-sa-tealBg': { bg: '#00aeef', color: '#ffffff' },
                                    'u-sa-blueLightBg': { bg: '#5eb6e4', color: null },
                                    'u-sa-navyBg': { bg: '#002d5a', color: '#ffffff' }
                                };
                                
                                let bgStyle = '';
                                let textColorClass = '';
                                if (item.backgroundColor && saBgClasses[item.backgroundColor]) {
                                    const colors = saBgClasses[item.backgroundColor];
                                    bgStyle = `background-color: ${colors.bg};`;
                                    if (colors.color) {
                                        textColorClass = ' text-white';
                                    }
                                }
                                
                                // Determine buttons/links
                                let buttonsHtml = '';
                                if (item.link || item.url || item.buttonUrl) {
                                    const url = item.link || item.url || item.buttonUrl;
                                    const label = item.buttonText || 'Find Out More';
                                    buttonsHtml = `<a href="${url}" class="btn btn-sm btn-secondary my-1 text-white shadow-sm" style="text-decoration:none;">${escapeHtml(label)}</a>`;
                                }
                                
                                if (imgUrl) {
                                    // MODERN OVERLAY CARD (Mosaic Style)
                                    return `
  <div class="col mb-2">
    <div class="card h-100 border-0 rounded-3 shadow-sm overflow-hidden d-grid position-relative" style="grid-template-columns: 100%; min-height: 250px; background-color: #f8f9fa;">
      <!-- Aspect Ratio Spacer (Gallery look) -->
      <div style="grid-area: 1/1; width: 100%; aspect-ratio: 1 / 1; pointer-events: none;"></div>
      
      <!-- Background Image -->
      <div style="grid-area: 1/1; background: url('${imgUrl}') no-repeat center center; background-size: cover; z-index: 1;"></div>
      
      <!-- Readable Gradient Overlay -->
      <div class="position-absolute w-100 h-100" style="grid-area: 1/1; background: linear-gradient(180deg, rgba(0,0,0,0) 40%, rgba(0,0,0,0.8) 100%); z-index: 2;"></div>
      
      <!-- Content Overlay -->
      <div class="d-flex align-items-end p-3 p-md-4" style="grid-area: 1/1; z-index: 3;">
        <div class="w-100 text-white">
          ${title ? `<h5 class="card-title fw-bold mb-1" style="text-shadow: 0 2px 4px rgba(0,0,0,0.8);">${title}</h5>` : ''}
          ${desc ? `<div class="card-text small opacity-90 mb-2" style="text-shadow: 0 1px 2px rgba(0,0,0,0.6);">${desc}</div>` : ''}
          ${buttonsHtml ? `<div class="d-flex flex-wrap gap-2 mt-2">${buttonsHtml}</div>` : ''}
        </div>
      </div>
    </div>
  </div>`;
                                }

                                // Standard Card Fallback
                                return `
  <div class="col mb-2">
    <div class="card h-100 border-0 shadow-sm rounded-3${textColorClass}" style="${bgStyle}">
      <div class="card-body d-flex flex-column">
        <h5 class="card-title${textColorClass ? '' : ' text-primary-emphasis'} fw-bold">${title}</h5>
        ${desc ? `<div class="card-text${textColorClass ? '' : ' text-muted'}">${desc}</div>` : ''}
        <div class="mt-auto pt-3 d-flex flex-wrap gap-2">${buttonsHtml}</div>
      </div>
    </div>
  </div>`;
                            }).join('\n');
                            
                            content = (content ? content + '\n' : '') + `<div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-4 justify-content-center">\n${cardsCols}\n</div>`;
                        }
                    }

                    // 4. Worship Schedule
                    if (propType.includes('worship')) {
                        const items = parseObjectsArray(prop.objects_array || prop.value);
                        if (Array.isArray(items) && items.length > 0) {
                            const worshipHtml = items.filter(item => {
                                const isActive = item.active !== false && item.active !== 'false' && item.active !== 0;
                                return isActive;
                            }).map(it => `
                                <div class="worship-item">
                                    <strong>${escapeHtml(it.day || '')} ${escapeHtml(it.time || '')}</strong>
                                    <p>${escapeHtml(it.description || '')}</p>
                                </div>
                            `).join('\n');
                            content = (content ? content + '\n' : '') + worshipHtml;
                        }
                    }

                    // 5. FormBuilder - display fields
                    // (REMOVED: User requested not to show form fields preview in HTML, but expose json config in properties list)
                    /*
                    if (propType.includes('formbuilder')) {
                       // ... logic removed ...
                    }
                    */

                    // 6. FreeTextArea with Background Image
                    if (propType.includes('freetextarea')) {
                        const imageKeys = ['background', 'background_image', 'backgroundImage', 'image', 'image_url', 'imageUrl', 'heroImage', 'src'];
                        let bgImage = null;
                        for (let k of imageKeys) {
                            if (prop[k] && typeof prop[k] === 'string' && prop[k].match(/https?:\/\/.+\.(png|jpe?g|gif|webp|svg)(\?.*)?$/i)) {
                                bgImage = prop[k];
                                break;
                            }
                        }
                        
                        // If a background image is found, wrap the content in a styled div
                        if (bgImage) {
                            let hasOverlay = false;
                            
                            // Check for white text in the content to determine if an overlay is needed for readability
                            try {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(content, 'text/html');
                                const hasWhiteText = Array.from(doc.body.querySelectorAll('*')).some(el => {
                                    const style = el.getAttribute('style') || '';
                                    return /color\s*:\s*(?:#ffffff|#fff|white|rgb\(\s*255\s*,\s*255\s*,\s*255\s*\))/i.test(style);
                                });
                                if (hasWhiteText) hasOverlay = true;
                            } catch(e) {}

                            // Manual override takes precedence
                            if (window.overlayOverrides && window.overlayOverrides.hasOwnProperty(prop.id)) {
                                 hasOverlay = window.overlayOverrides[prop.id];
                            }

                            const overlayHtml = hasOverlay ? `
                                <div class="position-absolute inset-0" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.4); z-index: 2;"></div>
                            ` : '';
                            
                            const textColorClass = hasOverlay ? 'text-white' : '';

                            // Clean and Constrain Content to ensure it doesn't blow out the aspect ratio
                            let cleanContent = content;
                            try {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(content, 'text/html');
                                
                                // 1. Remove empty/whitespace-only blocks (p, h1-h6) that take up vertical space
                                doc.querySelectorAll('p, h1, h2, h3, h4, h5, h6').forEach(el => {
                                    // Replace non-breaking spaces with normal spaces for trimming check
                                    const text = el.textContent.replace(/\u00a0/g, ' ').trim();
                                    if (!text && !el.querySelector('img, iframe, video, .btn, a, button, span.material-symbols-outlined')) {
                                        el.remove();
                                    }
                                });

                                // 2. Constrain internal images and handle alignment
                                doc.querySelectorAll('img').forEach(img => {
                                    img.style.maxHeight = '280px';
                                    img.style.maxWidth = '100%';
                                    img.style.width = 'auto';
                                    img.style.objectFit = 'contain';
                                    
                                    // User request: Default to left alignment unless already centered or aligned
                                    // Check if image or parent has centering classes/styles from old CMS
                                    const parent = img.parentElement;
                                    
                                    // Check if it's the "Lone Content" of its block parent
                                    // (Legacy CMS behavior: if an image is in its own paragraph, it's usually intended to be centered)
                                    const isLoneContent = parent && 
                                                         (parent.tagName === 'P' || parent.tagName === 'DIV' || parent.tagName === 'CENTER') &&
                                                         (parent.textContent.trim().length === 0) &&
                                                         (parent.querySelectorAll('img, video, iframe').length === 1);

                                    // Check for explicit left-alignment intent (Bootstrap classes or legacy align attribute)
                                    const hasLeftAlignment = img.classList.contains('float-start') || 
                                                             img.classList.contains('me-auto') ||
                                                             img.getAttribute('align') === 'left' ||
                                                             (parent && (parent.classList.contains('text-start') || parent.style.textAlign === 'left' || parent.getAttribute('align') === 'left'));

                                    const hasCentering = img.classList.contains('text-center') || 
                                                         img.classList.contains('mx-auto') || 
                                                         (img.style.textAlign === 'center') ||
                                                         (parent && (parent.classList.contains('text-center') || parent.style.textAlign === 'center' || parent.getAttribute('align') === 'center'));
                                    
                                    const hasAlignment = hasLeftAlignment || img.style.float || img.classList.contains('float-end') || 
                                                         img.getAttribute('align') || (parent && (parent.style.textAlign || parent.getAttribute('align')));

                                    if (isLoneContent && !hasAlignment) {
                                        // Automatically center "Lone" images in paragraphs unless they have explicit alignment
                                        img.classList.add('d-block', 'mx-auto', 'mb-3');
                                        img.style.display = 'block';
                                        img.style.marginLeft = 'auto';
                                        img.style.marginRight = 'auto';
                                    } else if (!hasCentering && !hasAlignment) {
                                        // If no centering or alignment is found, default to left
                                        // and ensure it doesn't inherit centering from a global wrapper
                                        img.style.display = 'block';
                                        img.style.marginLeft = '0';
                                        img.style.marginRight = 'auto';
                                    }
                                });
                                
                                // 3. Make iframes/videos responsive using wrapVideo structure
                                doc.querySelectorAll('iframe, video, embed, object').forEach(el => {
                                    // If already inside wrapVideo, skip
                                    if (el.closest('.wrapVideo')) return;

                                    const container = doc.createElement('div');
                                    container.className = 'container';
                                    const row = doc.createElement('div');
                                    row.className = 'row';
                                    const col = doc.createElement('div');
                                    col.className = 'col-12';
                                    const wrap = doc.createElement('div');
                                    wrap.className = 'wrapVideo';

                                    // Clean up attributes that might interfere with responsive wrapper
                                    el.removeAttribute('width');
                                    el.removeAttribute('height');

                                    const clonedEl = el.cloneNode(true);
                                    wrap.appendChild(clonedEl);
                                    col.appendChild(wrap);
                                    row.appendChild(col);
                                    container.appendChild(row);

                                    el.replaceWith(container);
                                });
                                
                                cleanContent = doc.body.innerHTML.trim();
                            } catch (e) {
                                console.warn('Content cleanup failed for freetextarea', e);
                            }

                            // Use separate background containers for Desktop (contain) and Mobile (cover)
                            // The content wrapper is NOT absolute, so it can stretch the container if it exceeds the aspect ratio.
                            // The Backgrounds use 'repeat-y' to tile vertically if the content forces the box to grow.
                            content = `
                                <div class="rounded overflow-hidden mb-4 d-grid position-relative" style="grid-template-columns: 100%; min-height: 300px; background-color: #f8f9fa;">
                                    <!-- Desktop Aspect Ratio Spacer (enforces MINIMUM ~1300/512 ratio) -->
                                    <div class="d-none d-md-block" style="grid-area: 1/1; width: 100%; aspect-ratio: 2.54 / 1; pointer-events: none;"></div>
                                    
                                    <!-- Mobile Aspect Ratio Spacer (enforces MINIMUM natural image ratio) -->
                                    <img src="${bgImage}" class="w-100 d-block d-md-none" style="grid-area: 1/1; visibility: hidden; pointer-events: none;">
                                    
                                    <!-- Desktop Background (Contain + Tiling) -->
                                    <div class="d-none d-md-block" style="grid-area: 1/1; background: url('${bgImage}') repeat center center; background-size: contain; z-index: 1;"></div>
                                    <!-- Mobile Background (Cover + Tiling) -->
                                    <div class="d-block d-md-none" style="grid-area: 1/1; background: url('${bgImage}') repeat center center; background-size: cover; z-index: 1;"></div>
                                    
                                    ${overlayHtml}
                                    
                                    <!-- Content Wrapper: Flow-based so it stretches the parent if needed -->
                                    <div class="d-flex align-items-center justify-content-start" style="grid-area: 1/1; z-index: 3;">
                                        <div class="w-100 p-4 p-md-5 ${textColorClass} text-start">
                                            ${cleanContent}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    }

                    return content;
                }

        function getFilterClass(filterName) {
            if (!filterName || filterName.includes('filter-none')) return '';
            
            // Map legacy filter names to opacity levels
            // Based on legacy CSS analysis: filter-black-trans was rgba(0,0,0,.6)
            if (filterName.includes('filter-black-trans')) return 'bg-photo-overlay bg-opacity-60';
            if (filterName.includes('filter-black-blue')) return 'bg-photo-overlay bg-opacity-60'; // Treat as dark overlay
            if (filterName.includes('filter-black-min')) return 'bg-photo-overlay bg-opacity-20';
            if (filterName.includes('filter-black-light')) return 'bg-photo-overlay bg-opacity-30';
            if (filterName.includes('filter-black-max')) return 'bg-photo-overlay bg-opacity-80';
            if (filterName.includes('filter-black')) return 'bg-photo-overlay bg-opacity-60';
            
            // Default fallback if filter is present but unknown
            if (filterName.includes('filter')) return 'bg-photo-overlay bg-opacity-40';
            
            return '';
        }

        function parseSlides(objectsArray, isSlideType = false) {
            // Parse slides from objects array - slides have background/backgroundMobile fields
            const slides = [];
            
            if (Array.isArray(objectsArray)) {
                objectsArray.forEach((item, index) => {
                    // Check for background image URL (desktop)
                    const imageUrl = item.background || item.backgroundImage || item.background_image || item.image || item.imageUrl || item.backgroundMobile || '';
                    
                    if (imageUrl) {
                        // Determine if slide is visible: Must be active and not expired
                        // Featured is often used as a secondary toggle or for specific layouts,
                        // but shouldn't exclusively determine 'active' status unless it's explicitly false.
                        const isActive = (item.active !== false && item.active !== 'false' && item.active !== 0);
                        const isFeatured = (item.featured !== false && item.featured !== 'false' && item.featured !== 0);
                        
                        const hasEnded = item.endDate ? new Date(item.endDate) < new Date() : false;
                        // For pure carousel/slide properties, featured: false usually means hidden.
                        // For generic card/list properties that happen to have background images, we ignore featured.
                        const isExpired = !isActive || hasEnded || (isSlideType && !isFeatured);
                        
                        // Extract title from title field - DON'T auto-generate "Slide X" if missing
                        const title = (item.title !== undefined && item.title !== null) ? item.title : '';
                        
                        // Generate fallback text for Alt tags / Internal labels
                        const altText = title || item.subtitle || `Slide ${index + 1}`;
                        
                        // Extract filename from URL
                        const urlParts = imageUrl.split('/');
                        const filename = urlParts[urlParts.length - 1];
                        
                        // Handle YouTube backgrounds
                        const isYoutube = item.backgroundType === 'video' && item.backgroundSource === 'youtube';
                        const isMobileYoutube = item.backgroundTypeMobile === 'video' && item.backgroundSourceMobile === 'youtube';
                        const youtubeId = isYoutube ? (item.background || '') : null;
                        const youtubeIdMobile = isMobileYoutube ? (item.backgroundMobile || '') : null;
                        
                        // Construct display URL (thumbnail for youtube, direct for others)
                        let displayImageUrl = imageUrl;
                        if (isYoutube && youtubeId) {
                            displayImageUrl = `https://img.youtube.com/vi/${youtubeId}/maxresdefault.jpg`;
                        }
                        
                        let displayImageMobile = item.backgroundMobile || '';
                        if (isMobileYoutube && youtubeIdMobile) {
                            displayImageMobile = `https://img.youtube.com/vi/${youtubeIdMobile}/maxresdefault.jpg`;
                        }

                        // Get mobile image filename
                        let mobileFilename = null;
                        if (item.backgroundMobile && item.backgroundMobile !== imageUrl) {
                            const mobileUrlParts = (item.backgroundMobile || '').split('/');
                            mobileFilename = mobileUrlParts[mobileUrlParts.length - 1];
                        }
                        
                        slides.push({
                            imageUrl: displayImageUrl,
                            imageMobile: displayImageMobile,
                            originalBackground: item.background || '',
                            originalBackgroundMobile: item.backgroundMobile || '',
                            hasMobileImage: !!(item.backgroundMobile && item.backgroundMobile !== imageUrl),
                            isVideo: isVideoUrl(imageUrl) || isYoutube,
                            isMobileVideo: isVideoUrl(item.backgroundMobile) || isMobileYoutube,
                            isYoutube: isYoutube,
                            isMobileYoutube: isMobileYoutube,
                            youtubeId: youtubeId,
                            youtubeIdMobile: youtubeIdMobile,
                            title: title,
                            altText: altText,
                            // Prefer explicit subtitle, otherwise fall back to description if present
                            subtitle: (item.subtitle || item.description || '').replace(/<p[^>]*>\s*(&nbsp;|\s|(<br\s*\/?>))*\s*<\/p>/gi, '').trim(),
                            // Keep raw description and url on the slide object for templates
                            description: (item.description || '').replace(/<p[^>]*>\s*(&nbsp;|\s|(<br\s*\/?>))*\s*<\/p>/gi, '').trim(),
                            url: item.url || '',
                            // Button mapping: prefer explicit buttonUrl, otherwise fall back to url
                            buttonText: item.buttonText || '',
                            buttonUrl: item.buttonUrl || item.url || '',
                            secondaryButtonText: item.secondaryButtonText || '',
                            secondaryButtonUrl: item.secondaryButtonUrl || '',
                            theaterImageUrl: item.theaterImageUrl || '',
                            customHtml: item.customHtml || '',
                            // keep legacy/backwards keys in case other code expects them
                            background: item.background || '',
                            backgroundMobile: item.backgroundMobile || '',
                            filename: filename,
                            mobileFilename: mobileFilename,
                            index: index,
                            isExpired: isExpired,
                            endDate: item.endDate || null,
                            startDate: item.startDate || null,
                            alignment: item.alignment || 'center',
                            filter: item.filter || '',
                            showButtons: item.showButtons,
                            rawData: item
                        });
                    }
                });
            }
            
            return slides;
        }

        function renderSlideMedia(slide, isMobile = false) {
            // Determine which media set to use:
            // "The youtube video background in the carousel and other carousel background types should always show on mobile 
            // unless there is a distinct backgroundMobile specified"
            const effectiveIsMobile = isMobile && slide.originalBackgroundMobile && (slide.originalBackgroundMobile !== slide.originalBackground);
            
            const isYoutube = effectiveIsMobile ? slide.isMobileYoutube : slide.isYoutube;
            const youtubeId = effectiveIsMobile ? slide.youtubeIdMobile : slide.youtubeId;
            const isVideo = effectiveIsMobile ? slide.isMobileVideo : slide.isVideo;
            const imageUrl = effectiveIsMobile ? slide.imageMobile : slide.imageUrl;
            
            if (isYoutube && youtubeId) {
                return `
                    <div class="slide-video-container" style="position:relative; width:100%; height:100%; min-height:180px; overflow:hidden; background:#000;">
                        <iframe src="https://www.youtube.com/embed/${youtubeId}?autoplay=0&mute=1&playlist=${youtubeId}&loop=1" 
                                style="position:absolute; top:0; left:0; width:100%; height:100%; border:0;" 
                                allow="autoplay; encrypted-media" allowfullscreen></iframe>
                    </div>`;
            } else if (isVideo && imageUrl) {
                return `
                    <video class="slide-video" autoplay muted loop playsinline style="width:100%; height:100%; object-fit:cover;">
                        <source src="${imageUrl}" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>`;
            } else {
                return `<img class="slide-thumbnail" src="${imageUrl}" alt="${escapeHtml(slide.altText)}" style="width:100%; height:100%; object-fit:cover;" loading="lazy" onerror="this.style.display='none'" />`;
            }
        }

        function buildSlideContent(slide, index) {
            // Build a copyable text representation of slide content
            let content = `=== Slide ${index + 1} ===\n`;
            if (slide.title) content += `Title: ${slide.title}\n`;
            if (slide.subtitle) content += `Subtitle: ${slide.subtitle}\n`;
            if (slide.buttonText) content += `Button: ${slide.buttonText}\n`;
            if (slide.buttonUrl) content += `Button URL: ${slide.buttonUrl}\n`;
            if (slide.secondaryButtonText) content += `Secondary Button: ${slide.secondaryButtonText}\n`;
            if (slide.secondaryButtonUrl) content += `Secondary Button URL: ${slide.secondaryButtonUrl}\n`;
            if (slide.customHtml) content += `Custom HTML: ${slide.customHtml}\n`;
            content += `Desktop Image: ${slide.background || ''}\n`;
            if (slide.backgroundMobile) content += `Mobile Image: ${slide.backgroundMobile}\n`;
            if (slide.theaterImageUrl) content += `Theater Link: ${slide.theaterImageUrl}\n`;
            if (slide.startDate) content += `Start Date: ${slide.startDate}\n`;
            if (slide.endDate) content += `End Date: ${slide.endDate}\n`;
            content += `\n`;
            return content;
        }

        function downloadAllSlides(propertyId) {
            // Filter out expired slides
            if (!window.currentSlides || !window.currentSlides[propertyId]) {
                alert('No slides found');
                return;
            }
            
            const slidesData = window.currentSlides[propertyId];
            const activeSlides = slidesData.filter(slide => !slide.isExpired);
            
            if (activeSlides.length === 0) {
                alert('No active slides to download.');
                return;
            }
            
            // Show feedback
            const totalDownloads = activeSlides.length + activeSlides.filter(s => s.hasMobileImage).length;
            if (confirm(`This will download ${totalDownloads} images (${activeSlides.length} desktop${activeSlides.filter(s => s.hasMobileImage).length > 0 ? ' + ' + activeSlides.filter(s => s.hasMobileImage).length + ' mobile' : ''}). Continue?`)) {
                let downloadCount = 0;
                
                activeSlides.forEach((slide, index) => {
                    // Download desktop image
                    setTimeout(() => {
                        const link = document.createElement('a');
                        link.href = slide.imageUrl;
                        link.download = slide.filename || `slide-${index + 1}-desktop.jpg`;
                        link.target = '_blank';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        downloadCount++;
                    }, index * 600);
                    
                    // Download mobile image if different
                    if (slide.hasMobileImage) {
                        setTimeout(() => {
                            const link = document.createElement('a');
                            link.href = slide.imageMobile;
                            link.download = slide.mobileFilename || `slide-${index + 1}-mobile.jpg`;
                            link.target = '_blank';
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            downloadCount++;
                        }, (index * 600) + 300);
                    }
                });
                
                // Show completion message
                setTimeout(() => {
                    alert(`Download initiated for ${downloadCount} images!`);
                }, (activeSlides.length * 600) + 500);
            }
        }

        function copyAllSlidesContent(propertyId) {
            // Filter out expired slides and get raw data
            // NOTE: If we are in "Include HTML generation mode" (detected by checking the property's toggle state), 
            // we should copy the Generated HTML instead of the JSON array.
            
            // Check manual content inclusion override
            let includeContent = false;
            if (window.slideContentOverrides && window.slideContentOverrides.hasOwnProperty(propertyId)) {
                 includeContent = window.slideContentOverrides[propertyId];
            }
            
            // If user has not explicitly toggled "Include Content", default behavior is JSON copy
            // BUT: The button says "Copy All JSON". So let's respect that and always copy JSON here?
            // The prompt "Copy All JSON" implies JSON. However, the user might want the HTML snippet.
            // Let's create a NEW function for copying the HTML snippet specifically, and leave this one for JSON.
            // Wait, the user clicks "Copy All JSON" on the UI.
            
            if (!window.currentSlides || !window.currentSlides[propertyId]) {
                alert('No slides found');
                return;
            }
            
            const slidesData = window.currentSlides[propertyId];
            const activeSlides = slidesData.filter(slide => !slide.isExpired);
            
            if (activeSlides.length === 0) {
                alert('No active slides to copy.');
                return;
            }
            
            // Default: Copy JSON
            const jsonArray = JSON.stringify(activeSlides.map(s => s.rawData), null, 2);
            navigator.clipboard.writeText(jsonArray).then(() => {
                alert(`Copied JSON array for ${activeSlides.length} active slides!`);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        // NEW FUNCTION: Copy the generated HTML for the carousel
        function copyCarouselHtml(propertyId) {
             const prop = (window.loadedProperties || []).find(p => p.id === propertyId);
             if (!prop)return;
             
             // We need to re-generate just the HTML for this property using the current logic
             // Ideally we'd extract the generation logic, but for now we can grab it from proper context or re-run buildPropertySnapshotHtml
             let html = buildPropertySnapshotHtml(prop);
             
             if (html) {
                 // Ensure transformations (anchors, responsive classes) are applied
                 html = transformFullHtml(html, prop, false);
                 navigator.clipboard.writeText(html).then(() => {
                    alert('Copied Carousel HTML to clipboard!');
                 });
             } else {
                 alert('No HTML generated for this property.');
             }
        }

        function viewRawData(propertyId) {
            const prop = (window.loadedProperties || []).find(p => p.id === propertyId);
            if (!prop || !prop.full_json_value) {
                alert('Raw database value not found for this property.');
                return;
            }
            
            // Create a temporary overlay to show raw data
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000; display:flex; flex-direction:column; padding:40px; box-sizing:border-box;';
            
            const header = document.createElement('div');
            header.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; color:white; flex-shrink:0;';
            header.innerHTML = `
                <div style="display:flex; flex-direction:column;">
                    <h2 style="margin:0; font-family:sans-serif;">Raw Database Value</h2>
                    <div style="font-size:12px; opacity:0.7; font-family:monospace;">${propertyId}</div>
                </div>
                <div>
                    <button id="copyRawBtn" style="padding:10px 20px; background:#444; color:white; border:none; border-radius:4px; cursor:pointer; margin-right:10px; font-weight:600;">Copy Value</button>
                    <button id="closeRawBtn" style="padding:10px 20px; background:#e03b2e; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Close</button>
                </div>
            `;
            
            const contentContainer = document.createElement('div');
            contentContainer.style.cssText = 'flex-grow:1; display:flex; flex-direction:column; overflow:hidden; position:relative;';
            
            const pre = document.createElement('pre');
            pre.style.cssText = 'flex-grow:1; background:#1e1e1e; color:#d4d4d4; padding:25px; border-radius:8px; overflow:auto; font-family:monospace; font-size:13px; border:1px solid #333; line-height:1.5; margin:0;';
            
            // Format if it looks like JSON
            let displayValue = prop.full_json_value;
            try {
                const parsed = JSON.parse(displayValue);
                displayValue = JSON.stringify(parsed, null, 2);
            } catch (e) {
                // Not JSON, display as is
            }
            pre.textContent = displayValue;
            
            contentContainer.appendChild(pre);
            overlay.appendChild(header);
            overlay.appendChild(contentContainer);
            document.body.appendChild(overlay);
            
            overlay.querySelector('#closeRawBtn').onclick = () => document.body.removeChild(overlay);
            overlay.querySelector('#copyRawBtn').onclick = () => {
                navigator.clipboard.writeText(prop.full_json_value).then(() => {
                    const btn = overlay.querySelector('#copyRawBtn');
                    const origText = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.style.background = '#28a745';
                    setTimeout(() => {
                        btn.textContent = origText;
                        btn.style.background = '#444';
                    }, 2000);
                });
            };

            // Close on escape
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function copySlideJson(propertyId, slideIndex) {
            // Copy individual slide's raw JSON
            if (!window.currentSlides || !window.currentSlides[propertyId] || !window.currentSlides[propertyId][slideIndex]) {
                alert('Slide data not found');
                return;
            }
            const slideData = window.currentSlides[propertyId][slideIndex].rawData;
            const jsonString = JSON.stringify(slideData, null, 2);
            navigator.clipboard.writeText(jsonString).then(() => {
                // Visual feedback handled by button
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function downloadSlideImage(propertyId, slideIndex, event, type) {
            // Prevent default and download without navigation
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Get slide data from global storage
            if (!window.currentSlides || !window.currentSlides[propertyId] || !window.currentSlides[propertyId][slideIndex]) {
                alert('Slide data not found');
                return;
            }
            
            const slide = window.currentSlides[propertyId][slideIndex];
            let imageUrl, filename;
            
            if (type === 'mobile') {
                imageUrl = slide.imageMobile;
                filename = slide.mobileFilename;
            } else {
                imageUrl = slide.imageUrl;
                filename = slide.filename;
            }
            
            if (!imageUrl) {
                alert('Image URL not found');
                return;
            }
            
            // Download the image/video
            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename || 'slide.' + (isVideoUrl(imageUrl) ? 'mp4' : 'jpg');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                })
                .catch(err => {
                    console.error('Download failed:', err);
                    // Fallback to direct link if CORS issue
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    link.download = filename || 'slide.' + (isVideoUrl(imageUrl) ? 'mp4' : 'jpg');
                    link.target = '_blank';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
        }
        
                // Toggle visibility of expired slides gallery for a property
                function toggleExpiredSlides(propId) {
                    const expiredGallery = document.getElementById(`expiredGallery-${propId}`);
                    const toggleBtn = document.getElementById(`expiredToggleBtn-${propId}`);
                    if (!expiredGallery || !toggleBtn) return;

                    const isHidden = expiredGallery.style.display === 'none' || expiredGallery.style.display === '';
                    if (isHidden) {
                        // Show as grid (same layout as .slides-gallery)
                        expiredGallery.style.display = 'grid';
                        const count = expiredGallery.children ? expiredGallery.children.length : 0;
                        toggleBtn.textContent = `Hide Expired Slides (${count})`;

                        // If the slides section is collapsed, expand it so user sees the expired slides
                        const slidesSection = document.getElementById(`slidesSection-${propId}`);
                        const slidesBtn = document.getElementById(`slidesToggleBtn-${propId}`);
                        if (slidesSection && slidesSection.classList.contains('collapsed')) {
                            slidesSection.classList.remove('collapsed');
                            if (slidesBtn) slidesBtn.textContent = 'Collapse Slides';
                        }
                    } else {
                        expiredGallery.style.display = 'none';
                        const count = expiredGallery.children ? expiredGallery.children.length : 0;
                        toggleBtn.textContent = `Show Expired Slides (${count})`;
                    }
                }

                // Collapse or expand the entire slides section for a property
                function toggleSlidesSection(propId) {
                    const slidesSection = document.getElementById(`slidesSection-${propId}`);
                    const slidesBtn = document.getElementById(`slidesToggleBtn-${propId}`);
                    if (!slidesSection || !slidesBtn) return;

                    if (slidesSection.classList.contains('collapsed')) {
                        slidesSection.classList.remove('collapsed');
                        slidesBtn.textContent = 'Collapse Slides';
                    } else {
                        slidesSection.classList.add('collapsed');
                        slidesBtn.textContent = 'Show Slides';
                    }
                }

                // Toggle entire property card collapsed/expanded for non-visible properties
                function toggleProperty(propId) {
                    const propCard = document.querySelector(`.property-card[data-prop-id="${propId}"]`) || document.getElementById(`propertyCard-${propId}`);
                    const btn = document.getElementById(`propToggleBtn-${propId}`);
                    if (!propCard || !btn) return;

                    if (propCard.classList.contains('property-collapsed')) {
                        propCard.classList.remove('property-collapsed');
                        btn.textContent = 'Hide Property';
                    } else {
                        propCard.classList.add('property-collapsed');
                        btn.textContent = 'Show Property';
                    }
                }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            // Hide metadata and results sections when error occurs
            document.getElementById('metadata').classList.remove('visible');
            document.getElementById('results').style.display = 'none';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadBtn').disabled = show;
        }

        // Real-time filter updates
        // searchFilter removed ‚Äî no real-time search listener

        document.getElementById('propertyTypeFilter').addEventListener('change', () => {
            if (properties.length > 0) applyPropertyFilters();
            saveFilterState();
        });

        document.getElementById('visibilityFilter').addEventListener('change', () => {
            if (properties.length > 0) applyPropertyFilters();
            saveFilterState();
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
